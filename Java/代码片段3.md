### 二、排序算法

#### 2.1.快速排序

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] arr = new int[]{5,2,6,1,7,4,9,8,3};
        sort(arr,0,arr.length);
        for(int i:arr){
            System.out.print(i+" ");
        }

    }


    public static void sort(int[] arr,int start,int end){
        if(start>=end) return ;
            int p_index = p_index(arr, start, end);
            sort(arr,start,p_index);
            sort(arr,p_index+1,end);
    }

    public static int p_index(int[] arr,int start,int end){

        int p_index = start;
        int p_value = arr[start];

        for(int i=start+1;i<end;i++){
            if(arr[i]<p_value){
                p_index ++;
                if(p_index!=i){
                    int tmp = arr[i];
                    arr[i] = arr[p_index];
                    arr[p_index] = tmp;
                }
            }

        }
        int tmp = arr[p_index];
        arr[p_index] = arr[start];
        arr[start] = tmp;

        return p_index;

    }
}
```

```java
copyFolder("E:\\projects\\taojiajia_TopFDIS_V1.4main3\\Lico\\lib","E:\\projects\\taojiajia_TopFDIS_V1.4main3\\MYLIB");
```



### 三、二维码

#### 3.1.二维码的生成与解析

```xml
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>core</artifactId>
    <version>3.3.2</version>
</dependency>
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>javase</artifactId>
    <version>3.3.2</version>
</dependency>
```

```java
//生成二维码
//String url = "14523";    //字符
//int width = 100;         //二维码的宽度
//int height = 100;        //二维码的高度
public void writeQRCode(String url,int width,int height){
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
        MultiFormatWriter writer = new MultiFormatWriter();
        Map<EncodeHintType, Object> hints = new HashMap<>();
        //设置生成的二维码的格式
        hints.put(EncodeHintType.CHARACTER_SET, "utf-8");
        BitMatrix bitMatrix = writer.encode(url, BarcodeFormat.QR_CODE, width,height, hints);
        MatrixToImageWriter.writeToStream(bitMatrix, "png", out);
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException("生成二维码出错", e);
    }
    //将生成的二维码64bit编码，然后再前台展示。
    System.out.println(Base64Utils.encodeToString(out.toByteArray()));
}
```

```java
//解析生成的二维码
public void readQRCOde() throws Exception{
    MultiFormatReader reader = new MultiFormatReader();
    BufferedImage bufferImage = 			              ImageIO.read(QRCodeTest.class.getClassLoader().getResourceAsStream("code.png"));
    //需要读取图片，并传入一个图片信息解析类
    Binarizer binarizer = new HybridBinarizer(new BufferedImageLuminanceSource(bufferImage));
    BinaryBitmap image = new BinaryBitmap(binarizer);
    //设置二维码的解码格式
    Map<DecodeHintType, String> hints = new HashMap<>();
    hints.put(DecodeHintType.CHARACTER_SET, "utf-8");

    //解析出二维码的内容
    Result result = reader.decode(image,hints);

    System.out.println(result);
    System.out.println("------------------------------------------");
    //二维码条形码格式
    System.out.println(result.getBarcodeFormat());
    System.out.println("------------------------------------------");
    //二维码的字符
    System.out.println(result.getText());  
}
```

### 四、数据库

#### 4.1.`c3p0 `连接和释放数据库

配置文件`（c3p0-config.xml） `

```xml
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <!--c3p0连接池配置文件-->
    <default-config>
        <property name="driverClass">com.mysql.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql:///jdbctest</property>
        <property name="user">root</property>
        <property name="password">root</property>
        <!--初始化时生成的连接数-->
        <property name="initialPoolSize">5</property>
        <!--最大连接数-->
        <property name="maxPoolSize">20</property>
    </default-config>
</c3p0-config>
```

```java
public class JDBCDataSourceUtils {
    private static ComboPooledDataSource dataSource = new ComboPooledDataSource();

    /**
     * 获得数据库连接
     * @return Connection 数据库连接对象
     */
    public static Connection getConnection() throws SQLException, ClassNotFoundException {
        Connection connection =  dataSource.getConnection();
        return connection;
    }

    /**
     * 资源释放方法，释放Statement 与 Connection
     * @param stmt
     * @param conn
     */
    public static void release(Statement stmt,Connection conn){
        if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            stmt = null;
        }

        if(conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            conn = null;
        }
    }

    /**
     *资源释放方法，释放Statement , Connection 与 ResultSet
     * @param rs
     * @param stmt
     * @param conn
     */
    public static void release( ResultSet rs,Statement stmt, Connection conn){
        if(rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            rs = null;
        }

        if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            stmt = null;
        }

        if(conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            conn = null;
        }
    }
}
```

#### 4.2.`jdbc`获取表结构 

```java
public void getTableDesc(){
    //1. JDBC连接MYSQL的代码很标准。 
    class.forName("com.mysql.jdbc.Driver").newInstance(); 
    Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/test?user=root&password=123456");

    //2. 下面就是获取表的信息。 
    m_DBMetaData = m_Connection.getMetaData(); 
    /*其中"%"就是表示*的意思，也就是任意所有的意思。其中m_TableName就是要获取的数据表的名字，如果想获取所有的表的名字，就可以使用"%"来作为参数了。*/
    ResultSet tableRet = m_DBMetaData.getTables(null, "%",m_TableName,new String[]{"TABLE"}); 
 
    //3. 提取表的名字。 
    while(tableRet.next) System.out.println(tableRet.getString("TABLE_NAME"));

    /*通过getString("TABLE_NAME")，就可以获取表的名字了。 
    从这里可以看出，前面通过getTables的接口的返回，JDBC是将其所有的结果，保存在一个类似table的内存结构中，而其中TABLE_NAME这个名字的字段就是每个表的名字。*/

    //4. 提取表内的字段的名字和类型 
    String columnName; 
    String columnType; 
    ResultSet colRet = m_DBMetaData.getColumns(null,"%", m_TableName,"%"); 
    while(colRet.next()) { 
      columnName = colRet.getString("COLUMN_NAME"); 
      columnType = colRet.getString("TYPE_NAME"); 
      int datasize = colRet.getInt("COLUMN_SIZE"); 
      int digits = colRet.getInt("DECIMAL_DIGITS"); 
      int nullable = colRet.getInt("NULLABLE"); 
      System.out.println(columnName+" "+columnType+" "+datasize+" "+digits+" "+ nullable); 
    }
}

/*JDBC里面通过getColumns的接口，实现对字段的查询。跟getTables一样，"%"表示所有任意的（字段），而m_TableName就是数据表的名字。

getColumns的返回也是将所有的字段放到一个类似的内存中的表，而COLUMN_NAME就是字段的名字，
TYPE_NAME就是数据类型，比如"int","int unsigned"等等，COLUMN_SIZE返回整数，就是字段的长度，
比如定义的int(8)的字段，返回就是8，最后NULLABLE，返回1就表示可以是Null,而0就表示Not Null。*/

```

```
/**更多列描述**/
TABLE_CAT String => 表类别（可为 null） 
TABLE_SCHEM String => 表模式（可为 null） 
TABLE_NAME String => 表名称 
COLUMN_NAME String => 列名称 
DATA_TYPE int => 来自 java.sql.Types 的 SQL 类型 
TYPE_NAME String => 数据源依赖的类型名称，对于 UDT，该类型名称是完全限定的 
COLUMN_SIZE int => 列的大小。 
BUFFER_LENGTH 未被使用。 
DECIMAL_DIGITS int => 小数部分的位数。对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。 
NUM_PREC_RADIX int => 基数（通常为 10 或 2） 
NULLABLE int => 是否允许使用 NULL。 
columnNoNulls - 可能不允许使用 NULL 值 
columnNullable - 明确允许使用 NULL 值 
columnNullableUnknown - 不知道是否可使用 null 
REMARKS String => 描述列的注释（可为 null） 
COLUMN_DEF String => 该列的默认值，当值在单引号内时应被解释为一个字符串（可为 null） 
SQL_DATA_TYPE int => 未使用 
SQL_DATETIME_SUB int => 未使用 
CHAR_OCTET_LENGTH int => 对于 char 类型，该长度是列中的最大字节数 
ORDINAL_POSITION int => 表中的列的索引（从 1 开始） 
IS_NULLABLE String => ISO 规则用于确定列是否包括 null。 
YES --- 如果参数可以包括 NULL 
NO --- 如果参数不可以包括 NULL 
空字符串 --- 如果不知道参数是否可以包括 null 
SCOPE_CATLOG String => 表的类别，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SCOPE_SCHEMA String => 表的模式，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SCOPE_TABLE String => 表名称，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SOURCE_DATA_TYPE short => 不同类型或用户生成 Ref 类型、来自 java.sql.Types 的 SQL 类型的源类型
（如果 DATA_TYPE 不是 DISTINCT 或用户生成的 REF，则为 null） 
IS_AUTOINCREMENT String => 指示此列是否自动增加 
YES --- 如果该列自动增加 
NO --- 如果该列不自动增加 
空字符串 --- 如果不能确定该列是否是自动增加参数 
COLUMN_SIZE 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。
对于日期时间数据类型，这是 String 表示形式的字符长度（假定允许的最大小数秒组件的精度）。
对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 
```

### 五、日期

#### 5.1.日期的转化

```java
import org.apache.commons.lang3.time.DateFormatUtils;  
  
import java.text.ParseException;  
import java.text.SimpleDateFormat;  
import java.util.Calendar;  
import java.util.Date;  
public class DateUtils extends org.apache.commons.lang3.time.DateUtils{
	private static String[] parsePatterns = {  
            "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM",  
            "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM",  
            "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"};  
  
    /** 
     * 得到当前日期字符串 格式（yyyy-MM-dd） 
     */  
    public static String getDate() {  
        return getDate("yyyy-MM-dd");  
    }  
  
    /** 
     * 得到当前日期字符串 格式（yyyy-MM-dd） pattern可以为："yyyy-MM-dd" "HH:mm:ss" "E" 
     */  
    public static String getDate(String pattern) {  
        return DateFormatUtils.format(new Date(), pattern);  
    }  
  
    /** 
     * 得到日期字符串 默认格式（yyyy-MM-dd） pattern可以为："yyyy-MM-dd" "HH:mm:ss" "E" 
     */  
    public static String formatDate(Date date, Object... pattern) {  
        if (date == null) {  
            return null;  
        }  
        String formatDate = null;  
        if (pattern != null && pattern.length > 0) {  
            formatDate = DateFormatUtils.format(date, pattern[0].toString());  
        } else {  
            formatDate = DateFormatUtils.format(date, "yyyy-MM-dd");  
        }  
        return formatDate;  
    }  
  
    /** 
     * 得到日期时间字符串，转换格式（yyyy-MM-dd HH:mm:ss） 
     */  
    public static String formatDateTime(Date date) {  
        return formatDate(date, "yyyy-MM-dd HH:mm:ss");  
    }  
  
    /** 
     * 得到当前时间字符串 格式（HH:mm:ss） 
     */  
    public static String getTime() {  
        return formatDate(new Date(), "HH:mm:ss");  
    }  
  
    /** 
     * 得到当前日期和时间字符串 格式（yyyy-MM-dd HH:mm:ss） 
     */  
    public static String getDateTime() {  
        return formatDate(new Date(), "yyyy-MM-dd HH:mm:ss");  
    }  
  
    /** 
     * 得到当前年份字符串 格式（yyyy） 
     */  
    public static String getYear() {  
        return formatDate(new Date(), "yyyy");  
    }  
  
    /** 
     * 得到当前月份字符串 格式（MM） 
     */  
    public static String getMonth() {  
        return formatDate(new Date(), "MM");  
    }  
  
    /** 
     * 得到当天字符串 格式（dd） 
     */  
    public static String getDay() {  
        return formatDate(new Date(), "dd");  
    }  
  
    /** 
     * 得到当前星期字符串 格式（E）星期几 
     */  
    public static String getWeek() {  
        return formatDate(new Date(), "E");  
    }  
  
    /** 
     * 日期型字符串转化为日期 格式 
     * { "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", 
     * "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", 
     * "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm" } 
     */  
    public static Date parseDate(Object str) {  
        if (str == null) {  
            return null;  
        }  
        try {  
            return parseDate(str.toString(), parsePatterns);  
        } catch (ParseException e) {  
            return null;  
        }  
    }  
  
    /** 
     * 获取过去的天数 
     * 
     * @param date 
     * @return 
     */  
    public static long pastDays(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (24 * 60 * 60 * 1000);  
    }  
  
    /** 
     * 获取过去的小时 
     * 
     * @param date 
     * @return 
     */  
    public static long pastHour(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (60 * 60 * 1000);  
    }  
  
    /** 
     * 获取过去的分钟 
     * 
     * @param date 
     * @return 
     */  
    public static long pastMinutes(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (60 * 1000);  
    }  
  
    /** 
     * 转换为时间（天,时:分:秒.毫秒） 
     * 
     * @param timeMillis 
     * @return 
     */  
    public static String formatDateTime(long timeMillis) {  
        long day = timeMillis / (24 * 60 * 60 * 1000);  
        long hour = (timeMillis / (60 * 60 * 1000) - day * 24);  
        long min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);  
        long s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);  
        long sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);  
        return (day > 0 ? day + "," : "") + hour + ":" + min + ":" + s + "." + sss;  
    }  
  
    /** 
     * 获取两个日期之间的天数 
     * 
     * @param before 
     * @param after 
     * @return 
     */  
    public static double getDistanceOfTwoDate(Date before, Date after) {  
        long beforeTime = before.getTime();  
        long afterTime = after.getTime();  
        return (afterTime - beforeTime) / (1000 * 60 * 60 * 24);  
    }  
  
    public static String getFirstDayOfMonth() {  
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");  
        //获取当前月第一天：  
        Calendar c = Calendar.getInstance();  
        c.add(Calendar.MONTH, 0);  
        c.set(Calendar.DAY_OF_MONTH, 1);//设置为1号,当前日期既为本月第一天  
        String first = format.format(c.getTime());  
        return first;  
    }  
  
    /** 
     * @param args 
     * @throws ParseException 
     */  
    public static void main(String[] args) throws ParseException {  
//      System.out.println(formatDate(parseDate("2010/3/6")));  
      System.out.println(getDate("yyyy-MM-dd HH:mm"));  
//      long time = new Date().getTime()-parseDate("2012-11-19").getTime();  
//      System.out.println(time/(24*60*60*1000));  
    }  
}
```

### 六、验证

#### 6.1.`Token`验证

```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.UUID;
import org.apache.commons.codec.digest.DigestUtils;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;


/**
 * Token验证的客户端实现
 * 
 * 2018-3-23 上午11:59:29 
 */
public class TokenClientDemo {


	// 应用的id
	public static final String appid = "totest11111111";
	
	// 应用id对应的key(在项目对接时，由服务端提供.【请妥善保管】)
	public static final String appkey = "En！@#￥%……&123";

	/**
	 * 校验token 服务端收到请求后将按appid 找到相应appkey，并按一样的方式计算token。两边token
	 * 匹配则权限认证成功。生成校验的Token
	 * 
	 * @param appid
	 * @param timestamp
	 * @param echostr
	 * @param appkey
	 * @return
	 * @throws Exception
	 */
	@SuppressWarnings("deprecation")
	private static String generateToken(String appid, String timestamp,
			String echostr, String appkey) throws Exception {
		String[] strArray = new String[] { appid, appkey, timestamp, echostr };
		Arrays.sort(strArray);
		ArrayList<String> strList = new ArrayList<String>();
		strList.add(appid);
		strList.add(timestamp);// 当前时间戳，毫秒
		strList.add(echostr);// 随机字符串
		strList.add(appkey);
		Collections.sort(strList);
		String token = DigestUtils.shaHex(strList.get(0) + strList.get(1)+ strList.get(2) + strList.get(3));
		return token;
	}

	/**
	 * URL请求相应
	 * 
	 * @param url
	 * @return
	 * @throws Exception
	 */
	private static Response httpRequest(String url) throws Exception {
		OkHttpClient client = new OkHttpClient();
		url=new String(url.getBytes("UTF-8") );
		// 2、设置请求头
		String timestamp = "";
		Date ts = new Date();
		DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			timestamp = sdf.format(ts);
		} catch (Exception e) {
			e.printStackTrace();
		}
		String echostr = UUID.randomUUID().toString().replace("-", "").substring(0, 8);
		String token = generateToken(appid, timestamp, echostr, appkey);
		Request request = new Request.Builder()
				.url(url)
				.get()
				.addHeader("appid", appid)
				.addHeader("timestamp", timestamp)
				.addHeader("echostr", echostr)
				.addHeader("token", token)
				.addHeader("cache-control", "no-cache")
				.addHeader("postman-token","74327b460dc0469").build();

		Response response = client.newCall(request).execute();
		// 连接五次、如果还失败就返回失败。
		for (int i = 0; i <= 5; i++) {
			if (!response.isSuccessful()) {
				response = client.newCall(request).execute();
			} else {
				break;
			}
		}
		return response;
	}
	
	
	/**
	 * 测试示例
	 * 
	 * 2018-3-23 下午12:02:47 
	 * @param args
	 */
	public static void main(String[] args) {
		String url = "http://127.0.0.1:8080/testweb/tokenInterface/tokenService.action?testCode=1";
		try {
			Response response= httpRequest(url);
			if (!response.isSuccessful()) {
				System.out.println("URL请求错误");
			}else{
				String str=response.body().string();
				
				//{"code":"Success","msg":"密钥验证成功"}
				System.out.println(str);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

#### 6.2. 身份证校验

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

/**
 * 身份证验证的工具（支持15位或18位省份证）
 * 身份证号码结构：
 * <p>
 * 根据〖中华人民共和国国家标准GB11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。
 * 排列顺序从左至右依次为：6位数字地址码，8位数字出生日期码，3位数字顺序码和1位数字校验码。
 * <p>
 * 地址码（前6位）：表示对象常住户口所在县（市、镇、区）的行政区划代码，按GB/T2260的规定执行。
 * <li>前1、2位数字表示：所在省份的代码；</li>
 * <li>第3、4位数字表示：所在城市的代码；</li>
 * <li>第5、6位数字表示：所在区县的代码；</li>
 * <p>
 * 出生日期码，（第7位 - 14位）：表示编码对象出生年、月、日，按GB按GB/T7408的规定执行，年、月、日代码之间不用分隔符。
 * <p>
 * 顺序码（第15位至17位）：表示在同一地址码所标示的区域范围内，对同年、同月、同日出生的人编订的顺序号，顺序码的奇数分配给男性，偶数分配给女性。
 * <li>第15、16位数字表示：所在地的派出所的代码；</li>
 * <li>第17位数字表示性别：奇数表示男性，偶数表示女性；</li>
 * <li>第18位数字是校检码：也有的说是个人信息码，一般是随计算机的随机产生，用来检验身份证的正确性。校检码可以是0~9的数字，有时也用x表示。</li>
 * <p>
 * 校验码（第18位数）：
 * <p>
 * 十七位数字本体码加权求和公式 s = sum(Ai*Wi), i = 0..16，先对前17位数字的权求和；
 * Ai:表示第i位置上的身份证号码数字值.Wi:表示第i位置上的加权因子.Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2；
 * 计算模 Y = mod(S, 11)
 * 通过模得到对应的模 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2
 * <p>
 * 计算步骤：
 * 1.将前17位数分别乘以不同的系数。从第1位到第17位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2
 * 2.将这17位数字和系数相乘的结果相加。
 * 3.用加出来和除以11，看余数是多少
 * 4.余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字，分别对应的最后一位身份证的号码为：1 0 X 9 8 7 6 5 4 3
 * <p>
 */
public class IDCardUtil
{
    /**
     * <pre>
     * 省、直辖市代码表：
     *     11 : 北京  12 : 天津  13 : 河北   14 : 山西  15 : 内蒙古
     *     21 : 辽宁  22 : 吉林  23 : 黑龙江 31 : 上海  32 : 江苏
     *     33 : 浙江  34 : 安徽  35 : 福建   36 : 江西  37 : 山东
     *     41 : 河南  42 : 湖北  43 : 湖南   44 : 广东  45 : 广西  46 : 海南
     *     50 : 重庆  51 : 四川  52 : 贵州   53 : 云南  54 : 西藏
     *     61 : 陕西  62 : 甘肃  63 : 青海   64 : 宁夏  65 : 新疆
     *     71 : 台湾
     *     81 : 香港  82 : 澳门
     *     91 : 国外
     * </pre>
     */
    final static String CITY_CODE[] = {"11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"};

    /**
     * 效验码
     */
    final static char[] PARITYBIT = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};

    /**
     * 加权因子
     * Math.pow(2,  i - 1) % 11
     */
    final static int[] POWER = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};

    /**
     * 身份证验证
     *
     * @param id 号码内容
     * @return 是否有效
     */
    public final static boolean isValid(String id){
        if (id == null)
            return false;

        int len = id.length();
        if (len != 15 && len != 18)
            return false;

        //校验区位码
        if (!validCityCode(id.substring(0, 2)))
            return false;

        //校验生日
        if (!validDate(id))
            return false;

        if (len == 15)
            return true;

        //校验位数
        return validParityBit(id);

    }

    private static boolean validParityBit(String id)
    {
        char[] cs = id.toUpperCase().toCharArray();
        int power = 0;
        for (int i = 0; i < cs.length; i++)
        {
            //最后一位可以是X
            if (i == cs.length - 1 && cs[i] == 'X')
                break;

            // 非数字
            if (cs[i] < '0' || cs[i] > '9')
                return false;

            // 加权求和
            if (i < cs.length - 1)
            {
                power += (cs[i] - '0') * POWER[i];
            }
        }
        return PARITYBIT[power % 11] == cs[cs.length - 1];
    }

    private static boolean validDate(String id){
        try{
            String birth = id.length() == 15 ? "19" + id.substring(6, 12) : id.substring(6, 14);
            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
            Date birthDate = sdf.parse(birth);
            if (!birth.equals(sdf.format(birthDate)))
                return false;
        }
        catch (ParseException e){
            return false;
        }
        return true;
    }

    private static boolean validCityCode(String cityCode){
        for (String code : CITY_CODE){
            if (code.equals(cityCode))
                return true;
        }
        return false;
    }

    /**
     * 将15位的身份证转成18位身份证
     *
     * @param id
     * @return
     */
    final public static String id15To18(String id){
        if (id == null || id.length() != 15)
            return null;

        if (!isValid(id))
            return null;

        String id17 = id.substring(0, 6) + "19" + id.substring(6);

        int power = 0;
        char[] cs = id17.toCharArray();
        for (int i = 0; i < cs.length; i++) {
            power += (cs[i] - '0') * POWER[i];
        }

        // 将前17位与第18位校验码拼接
        return id17 + String.valueOf(PARITYBIT[power % 11]);
    }

    /**
     * 生成随机整数
     * <p>
     *
     * @param min
     * @param max
     * @return
     */
    public static int rand(int min, int max){
        Random random = new Random();
        return random.nextInt(max + 1) % (max - min + 1) + min;
    }

    public final static String generateID(){
        // 地址码
        String body = CITY_CODE[rand(0, CITY_CODE.length - 1)] + "0101";

        // 出生年
        String y = String.valueOf(rand(1950, Calendar.getInstance().get(Calendar.YEAR)));
        String m = String.valueOf(rand(1, 12));
        if (m.length() == 1)
            m = "0" + m;
        String d = String.valueOf(rand(1, 28));
        if (d.length() == 1)
            d = "0" + d;

        String idx = String.valueOf(rand(1, 999));
        if (idx.length() == 1)
            idx = "00" + idx;
        else if (idx.length() == 2)
            idx = "0" + idx;

        body += y + m + d + idx;

        // 累加body部分与位置加权的积
        int power = 0;
        char[] cs = body.toCharArray();
        for (int i = 0; i < cs.length; i++)
        {
            power += (cs[i] - '0') * POWER[i];
        }

        // 得出校验码

        return body + String.valueOf(PARITYBIT[power % 11]);
    }
}
```

#### 6.3.数据格式校验

```java
import org.apache.commons.lang.StringUtils;

public class ValidUtils {

	private static final String mobile = "^(13|15|18|17|16)[0-9]{9}$";
	
	private static final String codeAndMobile = "^\\+[0-9]{2}\\-(13|15|18|17|16)[0-9]{9}$";
	
	/**整数*/
	private static final String intege="^-?[1-9]\\d*$";	
	/** 正整数*/
	private static final String intege1="^[1-9]\\d*$";					
	/** 负整数*/
	private static final String intege2="^-[1-9]\\d*$";					
	/** 数字*/
	private static final String num="^([+-]?)\\d*\\.?\\d+$";			
	/** 正数（正整数 + 0）*/
	private static final String num1="^[1-9]\\d*|0$";					
	/** 负数（负整数 + 0）*/
	private static final String num2="^-[1-9]\\d*|0$";					
	/** 浮点数*/
	private static final String decmal="^([+-]?)\\d*\\.\\d+$";			
	/** 正浮点数*/
	private static final String decmal1="^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$";	
	/** 负浮点数*/
	private static final String decmal2="^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$";
	/** 浮点数*/
	private static final String decmal3="^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$"; 
	/** 非负浮点数（正浮点数 + 0）*/
	private static final String decmal4="^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$"; 
	/**非正浮点数（负浮点数 + 0） */
	private static final String decmal5="^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$";
	/** 邮件*/
	private static final String email="^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$"; 
	/** 颜色*/
	private static final String color="^[a-fA-F0-9]{6}$";				
	/** url*/
	private static final String url="^http[s]?=\\/\\/([\\w-]+\\.)+[\\w-]+([\\w-./?%&=]*)?$";	
	/** 仅中文*/
	private static final String chinese="^[\\u4E00-\\u9FA5\\uF900-\\uFA2D]+$";					
	/** 仅ACSII字符*/
	private static final String ascii="^[\\x00-\\xFF]+$";				
	/**邮编 */
	private static final String zipcode="^\\d{6}$";						
	/** ip地址*/
	private static final String ip4="^(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$";	
	/** 非空*/
	private static final String notempty="^\\S+$";						
	/**图片 */
	private static final String picture="(.*)\\.(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$";	
	/** 压缩文件*/
	private static final String rar="(.*)\\.(rar|zip|7zip|tgz)$";								
	/** 日期*/
	private static final String date="^\\d{4}(\\-|\\/|\\.)\\d{1,2}\\1\\d{1,2}$";					
	/** QQ号码*/
	private static final String qq="^[1-9]*[1-9][0-9]*$";				
	/** 电话号码的函数(包括验证国内区号;国际区号;分机号)*/
	private static final String tel="^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)?(\\d{7,8})(-(\\d{1,}))?$";	
	/** 用来用户注册。匹配由数字、26个英文字母或者下划线组成的字符串*/
	private static final String username="^\\w+$";						
	/** 字母*/
	private static final String letter="^[A-Za-z]+$";					
	private static final String letterAndSpace="^[A-Za-z ]+$";					
	/** 大写字母*/
	private static final String letter_u="^[A-Z]+$";					
	/** 小写字母*/
	private static final String letter_l="^[a-z]+$";					
	/** 身份证*/
	private static final String idcard="^[1-9]([0-9]{14}|[0-9]{17})$";	
	/**判断字符串是否为浮点数*/
	private static final String isFloat="^[-]?\\d+(\\.\\d+)?$";
	/**判断字符串是否为正浮点数*/
	private static final String isUFloat="^\\d+(\\.\\d+)?$";
	/**判断是否是整数*/
	private static final String isInteger="^[-]?\\d+$";
	/**判断是否是正整数*/
	private static final String isUInteger="^\\d+$";
	/**判断车辆Vin码*/
	private static final String isCarVin="^[1234567890WERTYUPASDFGHJKLZXCVBNM]{13}[0-9]{4}$";
	/** 手机号 */
	public static boolean isMobile(String input){
		return matches(mobile, input);
	}
	public static boolean isCodeAndMobile(String input){
		return matches(codeAndMobile, input);
	}
	/** 整数 */
	public static boolean isIntege(String input){
		return matches(intege, input);
	}
	/** 正整数 */
	public static boolean isintege1(String input){
		return matches(intege1, input);
	}
	/** 负整数*/
	public static boolean isIntege2(String input){
		return matches(intege2, input);
	}
	/** 数字 */
	public static boolean isNum(String input){
		return matches(num, input);
	}
	/** 正数（正整数 + 0） */
	public static boolean isNum1(String input){
		return matches(num1, input);
	}
	/** 负数（负整数 + 0）*/
	public static boolean isNum2(String input){
		return matches(num2, input);
	}
	/** 浮点数*/
	public static boolean isDecmal(String input){
		return matches(decmal, input);
	}
	/** 正浮点数*/
	public static boolean isDecmal1(String input){
		return matches(decmal1, input);
	}
	/** 负浮点数*/
	public static boolean isDecmal2(String input){
		return matches(decmal2, input);
	}
	/**浮点数 */
	public static boolean isDecmal3(String input){
		return matches(decmal3, input);
	}
	/** 非负浮点数（正浮点数 + 0）*/
	public static boolean isDecmal4(String input){
		return matches(decmal4, input);
	}
	/** 非正浮点数（负浮点数 + 0）*/
	public static boolean isDecmal5(String input){
		return matches(decmal5, input);
	}
	/** 邮件*/
	public static boolean isEmail(String input){
		return matches(email, input);
	}
	/** 颜色*/
	public static boolean isColor(String input){
		return matches(color, input);
	}
	/** url*/
	public static boolean isUrl(String input){
		return matches(url, input);
	}
	/** 中文*/
	public static boolean isChinese(String input){
		return matches(chinese, input);
	}
	/** ascii码*/
	public static boolean isAscii(String input){
		return matches(ascii, input);
	}
	/** 邮编*/
	public static boolean isZipcode(String input){
		return matches(zipcode, input);
	}
	/** IP地址*/
	public static boolean isIP4(String input){
		return matches(ip4, input);
	}
	/** 非空*/
	public static boolean isNotEmpty(String input){
		return matches(notempty, input);
	}
	/** 图片*/
	public static boolean isPicture(String input){
		return matches(picture, input);
	}
	/** 压缩文件*/
	public static boolean isRar(String input){
		return matches(rar, input);
	}
	/** 日期*/
	public static boolean isDate(String input){
		return matches(date, input);
	}
	/** qq*/
	public static boolean isQQ(String input){
		return matches(qq, input);
	}
	/** 电话号码的函数(包括验证国内区号;国际区号;分机号)*/
	public static boolean isTel(String input){
		return matches(tel, input);
	}
	/** 用来用户注册。匹配由数字、26个英文字母或者下划线组成的字符串*/
	public static boolean isUserName(String input){
		return matches(username, input);
	}
	/**字母*/
	public static boolean isLetter(String input){
		return matches(letter, input);
	}
	public static boolean isLetterAndSpace(String input){
		return matches(letterAndSpace, input);
	}
	/** 小写字母*/
	public static boolean isLowLetter(String input){
		return matches(letter_l, input);
	}
	/** 大写字母*/
	public static boolean isUpperLetter(String input){
		return matches(letter_u, input);
	}
	/** 身份证*/
	public static boolean isIDCard(String input){
		return matches(idcard, input);
	}
	public static boolean isFloat(String input){
		return matches(isFloat, input);
	}
	public static boolean isUFloat(String input){
		return matches(isUFloat, input);
	}
	public static boolean isInteger(String input){
		return matches(isInteger, input);
	}
	public static boolean isUInteger(String input){
		return matches(isUInteger, input);
	}

	public static boolean isCarVin(String carVin){
		return matches(isCarVin, carVin);
	}

	public static boolean matches(String regex,String input){
		if(StringUtils.isBlank(input)) return false;
		if(input.matches(regex))return true;
		return false;
	}
	public static void main(String[] args) {
		/*System.out.println(isInteger("1"));
		System.out.println(isInteger("0"));
		System.out.println(isInteger("-1"));
		System.out.println(isInteger("1.0"));
		System.out.println("--------------------");
		System.out.println(isUInteger("-1"));
		System.out.println(isUInteger("0"));
		System.out.println(isUInteger("10"));
		System.out.println(isUInteger("1.3"));*/
		System.out.println(isLetterAndSpace("tai  wan"));
		
	}
}
```

### 七、数据结构

#### 7.1. 二叉树

```java
public class BinarySerachTree<T> {

	private Node<T> rootNode;//根节点
	
	private Comparator<Node<T>> comparable;
	
	public BinarySerachTree(Comparator<Node<T>> comparable) {
		this.comparable = comparable;
	}

	public Node<T> getRootNode() {
		return rootNode;
	}
	
	public void setRootNode(Node<T> rootNode) {
		this.rootNode = rootNode;
	}
	
	public void insertNode(T string){
		Node<T> node = new Node<>(string);
		if (this.rootNode == null ) {
			this.rootNode = node;
		}else {
			Node<T> currentNode = this.rootNode;
			for (;;) {
				int compareTo = comparable.compare(node, currentNode);
				if ( compareTo > 0) {  //大于等于走右边
					if (currentNode.getRight() == null) {
						currentNode.setRight(node);
						return;
					}else {
						currentNode = currentNode.getRight();
					}
				}else if (compareTo < 0){//小于走左边
					if (currentNode.getLeft() == null) {
						currentNode.setLeft(node);
						return;
					}else {
						currentNode = currentNode.getLeft();
					}
				}
			}	
		}	
	}
	
	
	
	public Node<T> getNode(Node<T> node){
		
		Node<T> currentNode = this.rootNode;
		for(;;){
			int compareTo = comparable.compare(node, currentNode);
			if (compareTo == 0) {
				return currentNode;
			}else if (compareTo > 0) {
				currentNode = currentNode.getRight();
			}else if (compareTo < 0) {
				currentNode = currentNode.getLeft();
			}
			
			if (currentNode == null) return null;
		}
	}
	
	
	

    public static class Node<T>{
        private T data;
        private Node<T> left;
        private Node<T> right;

        public Node(T data) {
            super();
            this.data = data;
        }
        public Node<T> getRight() {
            return right;
        }
        public void setRight(Node<T> right) {
            this.right = right;
        }
        public Node<T> getLeft() {
            return left;
        }
        public void setLeft(Node<T> left) {
            this.left = left;
        }
        public T getData() {
            return data;
        }
        public void setData(T data) {
            this.data = data;
        }
        @Override
        public String toString() {
            return "Node [data=" + data + ", left=" + left + ", right=" + right + "]";
        }
    }
}
```

#### 7.2.链表的插入

```java
public class LinkListTest {

    public static void main(String[] args) {
        ListNode tailNode = tailInsert(new int[]{1, 2, 3, 4});
        System.out.println(tailNode);
        ListNode headerNode = headInsert(new int[]{1, 2, 3, 4});
        System.out.println(headerNode);

    }

    /**
     * 头部插入
     * @param arr
     * @return
     */
    public static ListNode headInsert(int[] arr){
        ListNode head = null;
        for(int i=0;i<arr.length;i++){
            if(head == null){
                head = new ListNode(arr[i]);
            }else{
                ListNode cmp = new ListNode(arr[i]);
                cmp.next = head;
                head = cmp;
            }
        }
        return head;
    }

    /**
     * 尾部插入
     * @param arr
     * @return
     */
    public static ListNode tailInsert(int[] arr){
        ListNode head = null;
        ListNode p = null;

        for(int i=0;i<arr.length;i++){

            if(head == null){
                head = new ListNode(arr[i]);
                p = head;
            }else{
                while(p.next!=null){
                    p = p.next;
                }
                p.next = new ListNode(arr[i]);
            }

        }

        return  head;
    }

}
//节点
class ListNode{
    int val;
    ListNode(int val){this.val = val;}
    ListNode next;
}
```

#### 7.3.队列的实现

```java
import java.util.Arrays;
//顺序队列实现（使用数组，每次新增元素增加rear下标，删除元素增加rear下标，不能有效利用数组空间）
public class SeqQueue<T> {
	private int front;	//队头删除
	private int rear;	//队尾插入
	private T[] elementData;
	//private int queueLength;
	private int queueCapacity;
	private static final int DEAFAULT_LENGTH = 3;
	
	public SeqQueue(){
		front = rear = 0;
		queueCapacity = DEAFAULT_LENGTH;
		elementData = (T[]) new Object[DEAFAULT_LENGTH];
	}
	
	public SeqQueue(T element){
		this();
		elementData[0] = element;
		rear++;
	}
	
	public SeqQueue(int size){
		this();
		queueCapacity = size;
		elementData = (T[]) new Object[size];
//		elementData = new T[size];
	}
	
	public boolean isEmpty(){
		return rear == front;
	}
	
	public int getSize(){
		return rear - front;
	}
	
	public void add(T element){
		//ensureCapacity()判断是否可以插入，满的话开辟空间
		ensureCapacity(rear + 1);
		elementData[rear++] = element;
	}
	
	public void ensureCapacity(int minCapacity){
		int oldCapacity = elementData.length;
		if(minCapacity > oldCapacity){
			int newCapacity = oldCapacity*2+1;
			if(newCapacity < minCapacity)
				newCapacity = minCapacity;
			T[] old = elementData;
			//开辟新的数组空间
			elementData = (T[]) new Object[newCapacity];
			//将现在数组元素复制到新的数组
			int j = 0;
			for(int i = front;i<rear;i++){
				elementData[j++] = old[i];
			}
			front = 0;
			rear = j;
			
			//上面数组赋值可直接调用api
//			elementData = Arrays.copyOf(elementData, newCapacity);
		}
	}
	
	public T remove(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("数组为空");
		}
		T tempValue = elementData[front];
		elementData[front++] = null;
		return tempValue;
	}
	
	//返回队首元素，但不删除
	public T peek(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("数组为空");
		}
		return (T)elementData[front];
	}
	
	public void traverse(){
		for(int i = front; i<rear;i++){
			System.out.println(elementData[i]);
		}
	}
	
	public void clear(){
		elementData = null;
		front = rear =0;
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		SeqQueue<String> sq = new SeqQueue<>();
		sq.add("aa");
		sq.add("bb");
		sq.add("cc");
		String s = sq.peek();
		System.out.println(s);
		System.out.println("=====");
		sq.traverse();
		System.out.println("=====");
		sq.remove();
		sq.traverse();
		System.out.println("=====");
		sq.add("dd");
		sq.add("ee");
		sq.traverse();
		System.out.println("=====");
		sq.clear();
		System.out.println(sq.getSize());
	}
}
```

```java
//循环队列（使用数组，相当于把数组首尾相连构成循环队列，充分利用了数组空间）
public class CycleQueue <T> {

	private int front;
	private int rear;
	private int queueCapacity;
	private int queueLength;
	private static final int DEAFAULT_LENGTH = 4;
	private Object[] elementData;


	public CycleQueue() {
		front = rear = queueLength = 0;
		queueCapacity = DEAFAULT_LENGTH;
		elementData = new Object[DEAFAULT_LENGTH];
	}

	public CycleQueue(Object element){
		this();
		rear++;
		queueLength++;
		elementData[0] = element;
	}
	
	public CycleQueue(int size){
		this();
		queueCapacity = size;
		elementData = new Object[size];
	}
	
	public boolean isEmpty(){
		if(queueLength == 0)
			return true;
		return false;
	}

	public boolean isFull(){
		if(queueLength == queueCapacity)
			return true;
		return false;
	}
	
	public void clear(){
		elementData = null;
		rear = front = queueLength = 0;
	}
	
	public boolean add(T element){
		//
		if(isFull()){
			return false;
		}
		elementData[rear] = element;
		rear = (++rear) % queueCapacity;
		queueLength++;
		return true;
	}
	
	public T remove(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("ն쳣");
		}
		T element = (T) elementData[front];
		front = (++front) % queueCapacity;
		queueLength--;
		return element;
	}
	
	public void traverse(){
		for(int i=front;i<front+queueLength;i++){
			System.out.println(elementData[i % queueCapacity]);
		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		CycleQueue<String> cq = new CycleQueue<>();
		cq.add("1");
		cq.add("2");
		cq.add("3");
		cq.add("4");
		cq.add("5");
		cq.traverse();
		System.out.println();
		String tempValue = cq.remove();
		System.out.println(tempValue);
		System.out.println();
		cq.add("5");
		cq.traverse();
		cq.clear();
		cq.traverse();
	}

}
```

```java
//链式队列实现（使用内部类定义节点类型，定义节点front，rear指向队列头，尾）
public class LinkQueue<T> {

	//定义内部类实现节点类
	class Node{
		public T data;
		public Node next;
		
		public Node(){
			
		}
		public Node(T data,Node next){
			this.data = data;
			this.next = next;
		}
	}
	
	private Node front;
	private Node rear;
	private int size;
	
	public LinkQueue(){
		front = rear = null;
		size = 0;
	}
	public LinkQueue(T element){
		front = new Node(element, null);
		rear = front;
		size++;
	}
	
	public int getSize(){
		return size;
	}
	public boolean isEmpty(){
		return front == null;
	}
	
	public void add(T element){
		//判断是否是空队列
		if(isEmpty()){
			front = new Node(element, null);
			rear = front;
		}else{
			Node node = new Node(element, null);
			rear.next = node;
			rear = node;
		}
		
		size++;
	}
	
	public T remove(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("空队列异常");
		}
		Node oldFront = front;
		front = front.next;
		oldFront.next = null;
		size--;
		return oldFront.data;
	}
	//返回队首但不删除队首元素
	public T peek(){
		return front.data;
	}
	
	public void clear(){
		front = rear =null;
		size=0;
		
	}
	
	public void traverse(){
		//循环结束条件是current!=null(不是current.next这样最后一个就不会输出)
		for(Node current = front;current != null;current = current.next){
			System.out.println(current.data);
		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		LinkQueue<String> lq = new LinkQueue<>("aaa");
		lq.add("bbb");
		lq.add("ccc");
		System.out.println(lq.peek());
		System.out.println("-------");
		lq.traverse();
		System.out.println("-------");
		lq.remove();
		lq.add("ddd");
		lq.traverse();
	}
}
```

#### 7.4.栈

```java
//顺序栈的实现（使用数组，设置top下标指向数组头元素）
//java实现顺序栈
public class SeqStack<T> {

	private int top = 0;
	private int capacity;
	private T[] elementData;
	private static final int DEAFAULT_CAPACITY = 4;
	
	//使用默认大小初始化数组
	public SeqStack(){
		capacity = DEAFAULT_CAPACITY;
		elementData = (T[])(new Object[capacity]);
	}
	//指定数组大小初始化
	public SeqStack(int capacity){
		this.capacity = capacity;
		elementData = (T[])new Object[capacity];
	}
	//给定栈顶元素初始化
	public SeqStack(T element){
		this();
		elementData[0] = element;
		top++;
	}
	//给栈顶和数组大小初始化
	public SeqStack(T element,int capacity){
		this.capacity = capacity;
		elementData = (T[]) new Object[capacity];
		elementData[0] = element;
		top++;
	}
	
	public boolean isEmpty(){
		return top == 0;
	}
	public boolean isFull(){
		return top == capacity;
	}
	
	public boolean push(T element){
		if(isFull()){
			return false;
		}
		elementData[top++] = element;
		return true;
		
	}
	
	//弹出栈顶元素即是将top--，使原来栈顶元素不能访问，数组空间没变
	public T pop(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("栈为空");
		}
		return elementData[--top];
		
	}
	
	//返回栈顶元素，并不删除
	public T peek(){
		if(isEmpty()){
			throw new IndexOutOfBoundsException("栈为空");
		}
		return elementData[top - 1];
	}
	
	public void traverse(){
		for(int i=0;i<top;i++){
			System.out.println(elementData[i]);
		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		SeqStack<String> ss = new SeqStack<>("aaa",3);
		ss.push("bbb");
		ss.push("ccc");
		ss.traverse();
		System.out.println("=======");
		ss.push("ddd");
		ss.traverse();
		
	}
}
```

```java
//顺序栈的应用，字符串匹配
public class Match {
	public static void main(String[] args) {
		String str = "[({})]";
		SeqStack<Character> test = new SeqStack<>(20);
		int flag = 0;
		for(int i=0;i<str.length();i++){
			char ch = str.charAt(i);
			switch(ch){
				case '(':
					test.push(ch);
					break;
				case '[':
					test.push(ch);
					break;
				case '{':
					test.push(ch);
					break;
				case ')':
					if(test.isEmpty()){
						flag = 1;
					}else{
						if(test.pop() == '('){
						}else{
							flag = 1;
						}
					}
					
					break;
				case ']':
					if(test.isEmpty()){
						flag = 1;
					}else{
						if(test.pop() == '['){
						}else{
							flag = 1;
						}
					}
					break;
				case '}':
					if(test.isEmpty()){
						flag = 1;
					}else{
						if(test.pop() == '{'){
						}else{
							flag = 1;
						}
					}
					break;
			}
		}
		if(test.isEmpty() && flag == 0){
			System.out.println("ַƥȷ");
		}else{
			System.out.println("ƥ");
		}
	}
}
```

```java
//顺序栈的应用，将数转化为16进制，因为栈中存放的是数字，利用数字和数组下标对应关系将数字转化为16进制数
import java.util.Scanner;

public class Convert {
	//将一个数转化为16进制
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//转化为十六进制因为栈中存放的是小于16的余数，这里要定义数组使余数与下标对应
		char num[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
		SeqStack<Integer> sq = new SeqStack<>(10);
		
		System.out.println("请输入要转化的十进制数");
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int result = 0;
		while(n != 0){
			result = n%16;
			sq.push(result); 
			n = n / 16;
		}
		
		while(!sq.isEmpty()){
			int number = sq.pop();
			System.out.print(num[number]);
		}
		System.out.println();
		
	}
}
```

```java
//链式栈的实现，定义内部类作为Node，设置top指向栈顶Node
public class LinkStack<T> {

	class Node{
		private T data;
		private Node next;
		
		public Node(){}
		public Node(T data,Node next){
			this.data = data;
			this.next = next;
		}
		
	}
	
	private Node top;	//栈顶元素
	private int size;
	
	public LinkStack(){
		top = null;
	}
	public LinkStack(T element){
		top = new Node(element,null);
		size++;
	}
	
	public int getSize(){
		return size;
	}
	public void push(T element){
		//新加入节点作为top，它的next指向原来的top节点
		top = new Node(element,top);
//		top = node;
		size++;
	}
	public T pop() throws IndexOutOfBoundsException{
		if(top != null){
			Node old = top;
			top = top.next;
			old.next = null;
			size--;
			return old.data;
		}else{
			throw new IndexOutOfBoundsException("栈为空");
		}
	}
	public T peek() throws IndexOutOfBoundsException{
		if(top != null)
			return top.data;
		else
			throw new IndexOutOfBoundsException("栈为空");
	}
	public boolean isEmpty(){
		return size == 0;
	}
	public void clear(){
		top = null;
		size = 0;
	}
	public void traverse(){
		for(Node current = top;current != null;current = current.next){
			System.out.println(current.data);
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		LinkStack<String> ls = new LinkStack<>();
		ls.push("aaa");
		ls.push("bbb");
		ls.traverse();
		System.out.println("====");
//		System.out.println(ls.peek());
		ls.pop();
		ls.push("ccc");
		ls.traverse();
		System.out.println("====");
		ls.pop();
		String s = ls.pop();
		System.out.println(s);
		ls.traverse();
		System.out.println("====");
		try{
			String ss = ls.pop();
			System.out.println(ss);
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
```









### 八、图像

#### 8.1. 旋转图片

```java
public BufferedImage rotate90DX(BufferedImage bi)
{
    int width = bi.getWidth();
    int height = bi.getHeight();
     
    BufferedImage biFlip = new BufferedImage(height, width, bi.getType());
     
    for(int i=0; i<width; i++)
        for(int j=0; j<height; j++)
            biFlip.setRGB(height-1-j, width-1-i, bi.getRGB(i, j));
     
    return biFlip;
}


public BufferedImage rotate90SX(BufferedImage bi)
{
    int width = bi.getWidth();
    int height = bi.getHeight();
     
    BufferedImage biFlip = new BufferedImage(height, width, bi.getType());
     
    for(int i=0; i<width; i++)
        for(int j=0; j<height; j++)
            biFlip.setRGB(j, i, bi.getRGB(i, j));
     
    return biFlip;
}
```

#### 8.2.图片`Exif`读取工具

```java
<!-- 图片EXIF信息读取工具 -->
<dependency>
    <groupId>com.drewnoakes</groupId>
    <artifactId>metadata-extractor</artifactId>
    <version>2.11.0</version>
</dependency>
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.6</version>
</dependency>
```

```java
package com.dqv5.photoAlbum.util;

import com.drew.imaging.ImageMetadataReader;
import com.drew.imaging.ImageProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;
import com.drew.metadata.exif.ExifSubIFDDirectory;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;


public class ExifUtil {
    private File file;

    public ExifUtil() {

    }

    public ExifUtil(File file) {
        this.file = file;
    }


    /**
     * 获取照片的EXIF信息
     *
     * @param file
     * @return [directoryName, tagName, description]
     * @throws ImageProcessingException
     * @throws IOException
     */
    public List readMetadata() {
        Metadata metadata = null;
        List list = new ArrayList();
        try {
            metadata = ImageMetadataReader.readMetadata(file);
            for (Directory directory : metadata.getDirectories()) {
                for (Tag tag : directory.getTags()) {
                    list.add(String.format("%-15s %-30s %-1s", directory.getName(), tag.getTagName(), tag.getDescription()));
                }
                if (directory.hasErrors()) {
                    for (String error : directory.getErrors()) {
                        System.err.format("ERROR: %s", error);
                    }
                }
            }
        } catch (ImageProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return list;
    }

    /**
     * 获取照片拍摄时间
     *
     * @param file
     * @return
     * @throws ImageProcessingException
     * @throws IOException
     */
    public Date readOriginalDate() {
        Metadata metadata = null;
        Date date = null;
        try {
            metadata = ImageMetadataReader.readMetadata(file);
            ExifSubIFDDirectory directory = metadata.getFirstDirectoryOfType(ExifSubIFDDirectory.class);
            TimeZone timeZone = TimeZone.getTimeZone("Asia/Shanghai");
            date = directory.getDate(ExifSubIFDDirectory.TAG_DATETIME_ORIGINAL, timeZone);
        } catch (ImageProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return date;
    }

    /**
     * @return YYYY:MM:dd HH:mm:ss
     */
    public String getOriginalDate() {
        Metadata metadata = null;
        String str = null;
        try {
            metadata = ImageMetadataReader.readMetadata(file);
            TimeZone timeZone = TimeZone.getTimeZone("Asia/Shanghai");
            Collection<ExifSubIFDDirectory> directorys = metadata.getDirectoriesOfType(ExifSubIFDDirectory.class);
            for (ExifSubIFDDirectory directory : directorys) {
                if (directory != null) {
                    Date date = directory.getDate(ExifSubIFDDirectory.TAG_DATETIME_ORIGINAL, timeZone);
                    if (date != null) {
                        str = new SimpleDateFormat("YYYY:MM:dd HH:mm:ss").format(date);
                        return str;
                    }
                }
            }
            for (Directory directory : metadata.getDirectories()) {
                for (Tag tag : directory.getTags()) {
                    if (tag.getTagName().toUpperCase().contains("ORIGINAL") && tag.getTagName().toUpperCase().contains("DATE")) {
                        str = tag.getTagName();
                        return str;
                    }
                }
            }
        } catch (ImageProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }


    public void rename() {
        String str = getOriginalDate();
        if (str != null) {
            try {
                String dir = file.getParent();
                String oldName = file.getName();
                String suffix = oldName.substring(oldName.lastIndexOf("."));
                str = str.replace(":", "").replace(" ", "_");
                String fileName = str.replace(":", "").replace(" ", "_") + suffix;
                File destFile = new File(dir, fileName);
                if (!destFile.exists()) {
                    FileUtils.moveFile(file, destFile);
                } else {
                    for (int i = 1; i < 10; i++) {

                    }
                    System.err.println("exist:" + destFile + ",  oldFile:" + file.getName());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }


    public File getFile() {
        return file;
    }

    public void setFile(File file) {
        this.file = file;
    }

    public static void main(String[] args) throws ImageProcessingException, IOException {
    }
}

```





### 九、工具

#### 9.1.`maven`仓库无效文件清理

```java
public class Clean {

    public static void main(String[] args) {
        findAndDelete(new File("G:\\.m2\\repository"));
    }

    public static boolean findAndDelete(File file) {
        if (!file.exists()) {
        } else if (file.isFile()) {
            if (file.getName().endsWith("lastUpdated")) {
                deleteFile(file.getParentFile());
                return true;
            }
        } else if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (File f : files) {
                if (findAndDelete(f)) {
                    break;
                }
            }
        }
        return false;
    }

    public static void deleteFile(File file) {
        if (!file.exists()) {
        } else if (file.isFile()) {
            print("删除文件:" + file.getAbsolutePath());
            file.delete();
        } else if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (File f : files) {
                deleteFile(f);
            }
            print("删除文件夹:" + file.getAbsolutePath());
            print("====================================");
            file.delete();
        }
    }

    public static void print(String msg) {
        System.out.println(msg);
    }
}
```

#### 9.2.隐藏身份证，中间加`*`

```java
/**
 * 描述：隐藏身份证号码，中间加*隐藏
 * @param idCardNum
 * @param front  显示前几位数字
 * @param end	 显示后几位数字
 * @return
 */
public static String idMask(String idCardNum, int front, int end) {
    // 身份证不能为空
    if (TextUtils.isEmpty(idCardNum)) {
        return null;
    }
    // 需要截取的长度不能大于身份证号长度
    if ((front + end) > idCardNum.length()) {
        return null;
    }
    // 需要截取的不能小于0
    if (front < 0 || end < 0) {
        return null;
    } // 计算*的数量
    int asteriskCount = idCardNum.length() - (front + end);
    StringBuffer asteriskStr = new StringBuffer();
    for (int i = 0; i < asteriskCount; i++) {
        asteriskStr.append("*");
    }
    String regex = "(\\w{" + String.valueOf(front) + "})(\\w+)(\\w{" + String.valueOf(end) + "})";
    return idCardNum.replaceAll(regex, "$1" + asteriskStr + "$3");

}
```

#### 9.3.`Jackson`序列化工具 

```java
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.module.SimpleModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;


/**
 * Jackson工具类
 */
public class JsonUtil {
    /**
     * 年月日 yyyy-MM-dd
     */
    private static final String DATE_FORMAT = "yyyy-MM-dd";
    /**
     * 24小时制 yyyy-MM-dd HH:mm:ss
     */
    private static final String DATETIMEPATTERN24H = "yyyy-MM-dd HH:mm:ss";
    /**
     * Base ISO 8601 Date format yyyyMMdd i.e., 20021225 for the 25th day of December in the year 2002
     */
    private static final String ISO_DATE_FORMAT = "yyyyMMdd";
    /**
     * 所有值全部打印，时间以时间戳格式显示
     */
    private static final ObjectMapper mapper;
    /**
     * 空值过滤掉(""和NULL)，时间以时间戳格式显示
     */
    private static final ObjectMapper mapperNotEmpty;
    /**
     * 所有值全部打印，时间以24小时制格式显示
     */
    private static final ObjectMapper mapperWithTime;
    /**
     * 空值过滤掉(""和NULL)，时间以24小时制格式显示
     */
    private static final ObjectMapper mapperNotEmptyWithTime;
    /**
     * 日志
     */
    private static Logger logger = LoggerFactory.getLogger(JsonUtil.class);

    static {
        SimpleModule module = new SimpleModule();
        module.addDeserializer(java.sql.Date.class, new JsonSqlDateDeserializer());
        module.addDeserializer(Timestamp.class, new JsonDateTimestampDeserializer());
        module.addDeserializer(Time.class, new JsonTimeDeserializer());
        module.addDeserializer(Date.class, new JsonDateDeserializer());

        mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
        mapper.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, true);
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);//1
        mapper.registerModule(module);

        /*
         * 1.反序列化一个Json字符串为指定的POJO，而且字符串中有一个Field在POJO中不存在，应该抛出错误。jackson默认是中止，需关闭。
         */
        mapperNotEmpty = new ObjectMapper();
        mapperNotEmpty.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        mapperNotEmpty.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, true);

        mapperWithTime = new ObjectMapper();
        mapperWithTime.setSerializationInclusion(JsonInclude.Include.ALWAYS);
        mapperWithTime.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, true);
        mapperWithTime.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapperWithTime.setDateFormat(new SimpleDateFormat(DATETIMEPATTERN24H));


        mapperNotEmptyWithTime = new ObjectMapper();
        mapperNotEmptyWithTime.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        mapperNotEmptyWithTime.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, true);
        mapperNotEmptyWithTime.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapperNotEmptyWithTime.setDateFormat(new SimpleDateFormat(DATETIMEPATTERN24H));
    }

    private static Date string2Date(String dateString) {
        if (dateString == null || dateString.trim().length() == 0) return null;
        dateString = dateString.trim();
        if (dateString.matches("^-?[0-9]+$")) return new Date(Integer.parseInt(dateString));
        if (dateString.length() <= 10) dateString = dateString.concat(" 00:00:00");
        try {
            DateFormat df = new SimpleDateFormat(DATETIMEPATTERN24H);
            return df.parse(dateString);
        } catch (ParseException e) {
            logger.error(e.getMessage());
        }
        return null;
    }

    /**
     * Object 转 Json
     * 如果对象为Null, 返回"null".
     * 如果集合为空集合, 返回"[]".
     */
    public static <T> String obj2Json(T t) {
        if (t == null) return null;
        try {
            return t instanceof String ? (String) t : mapper.writeValueAsString(t);
        } catch (IOException e) {
            logger.error("{} 对象转Json串失败，失败原因：{}", t, e.getMessage());
            return null;
        }
    }

    /**
     * Object 转 Json
     * 过滤空值
     */
    public static <T> String obj2JsonNotEmpty(T t) {
        if (t == null) return null;
        try {
            return t instanceof String ? (String) t : mapperNotEmpty.writeValueAsString(t);
        } catch (IOException e) {
            logger.error("{} 对象转Json串失败，失败原因：{}", t, e.getMessage());
            return null;
        }
    }

    /**
     * Object 转 Json
     * 过滤时间
     */
    public static <T> String obj2JsonWithTime(T t) {
        if (t == null) return null;
        try {
            return t instanceof String ? (String) t : mapperWithTime.writeValueAsString(t);
        } catch (IOException e) {
            logger.error("{} 对象转Json串失败，失败原因：{}", t, e.getMessage());
            return null;
        }
    }

    /**
     * Object 转 Json
     * 过滤空值和时间
     */
    public static <T> String obj2JsonNotEmptyWithTime(T t) {
        if (t == null) return null;
        try {
            return t instanceof String ? (String) t : mapperNotEmptyWithTime.writeValueAsString(t);
        } catch (IOException e) {
            logger.error("{} 对象转Json串失败，失败原因：{}", t, e.getMessage());
            return null;
        }
    }

    /**
     * JSON 字符串转换为 map 或 list
     *
     * @param json      JSON 字符串
     * @param valueType map 或 list
     * @return 泛型对象
     */
    public static <T> T json2MapOrList(String json, TypeReference<T> valueType) {
        if (json == null || json.length() == 0 || "nil".equals(json))
            return null;
        try {
            return mapper.readValue(json, valueType);
        } catch (JsonParseException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getType(), e.getMessage());
        } catch (JsonMappingException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getType(), e.getMessage());
        } catch (IOException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getType(), e.getMessage());
        }
        return null;
    }

    /**
     * json字符串 转 Javabean对象
     */
    public static <T> T json2Bean(String json, Class<T> valueType) {
        if (json == null || json.length() == 0 || "nil".equals(json))
            return null;
        try {
            return mapper.readValue(json, valueType);
        } catch (JsonParseException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getName(), e.getMessage());
        } catch (JsonMappingException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getName(), e.getMessage());
        } catch (IOException e) {
            logger.error("{} 字符串转换{}对象失败！失败原因：{}", json, valueType.getName(), e.getMessage());
        }
        return null;
    }

    /**
     * 统一获取返回的 json 格式
     * code 错误编码；msg 错误信息；obj 返回数据。
     */
    public static String getResponseJson(int code, String msg, Object obj) {
        return getResponseJson(code, msg, obj, null);
    }

    /**
     * 统一获取返回的json格式
     * code 错误编码；msg 错误信息；obj 返回数据，callback 回调函数。
     */
    public static String getResponseJson(int code, String msg, Object obj, String callback) {
        Map<String, Object> map = new HashMap<>();
        map.put("code", code);
        map.put("msg", msg);
        if (obj == null) {
            obj = "null";
        }
        map.put("obj", obj);
        String json = obj2Json(map);
        if (callback != null && callback.trim().length() != 0) {
            json = callback.concat("(").concat(json).concat(")");
        }
        return json;
    }

    public static String getResponseJsonWithTime(int code, String msg, Object obj) {
        return getResponseJsonWithTime(code, msg, obj, null);
    }

    /**
     * 统一获取返回的json格式
     * code 错误编码；msg 错误信息；obj 返回数据，callback 回调函数。
     */
    public static String getResponseJsonWithTime(int code, String msg, Object obj, String callback) {
        Map<String, Object> map = new HashMap<>();
        map.put("code", code);
        map.put("msg", msg);
        if (obj == null) {
            obj = "null";
        }
        map.put("obj", obj);
        String json = obj2JsonWithTime(map);
        if (callback != null && callback.trim().length() != 0) {
            json = callback.concat("(").concat(json).concat(")");
        }
        return json;
    }

    public static String getResponseJsonNotEmptyWithTime(int code, String msg, Object obj) {
        return getResponseJsonNotEmptyWithTime(code, msg, obj, null);
    }

    /**
     * 统一获取返回的json格式
     * code 错误编码；msg 错误信息；obj 返回数据，callback 回调函数。
     */
    public static String getResponseJsonNotEmptyWithTime(int code, String msg, Object obj, String callback) {
        Map<String, Object> map = new HashMap<>();
        map.put("code", code);
        map.put("msg", msg);
        if (obj == null) {
            obj = "null";
        }
        map.put("obj", obj);
        String json = obj2JsonNotEmptyWithTime(map);
        if (callback != null && callback.trim().length() != 0) {
            json = callback.concat("(").concat(json).concat(")");
        }
        return json;
    }

    /**
     * 统一获取返回的 json 格式
     * code 错误编码；msg 错误信息；obj 返回数据。
     */
    public static String getResponseJsonNotEmpty(int code, String msg, Object obj) {
        return getResponseJsonNotEmpty(code, msg, obj, null);
    }

    /**
     * 统一获取返回的json格式
     * code 错误编码；msg 错误信息；obj 返回数据，callback 回调函数。
     */
    public static String getResponseJsonNotEmpty(int code, String msg, Object obj, String callback) {
        Map<String, Object> map = new HashMap<>();
        map.put("code", code);
        map.put("msg", msg);
        map.put("obj", obj);
        String json = obj2JsonNotEmpty(map);
        if (callback != null && callback.trim().length() != 0) {
            json = callback.concat("(").concat(json).concat(")");
        }
        return json;
    }

    /**
     * 统一返回错误的信息
     */
    public static String getResponseJson(String err, String msg) {
        Map<String, Object> map = new HashMap();
        map.put("err", err);
        map.put("msg", msg);
        String json = obj2Json(map);
        return json;
    }

    private static class JsonDateDeserializer extends JsonDeserializer<Date> {

        @Override
        public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
            try {
                String dateString = jsonParser.getText();
                return string2Date(dateString);
            } catch (Exception e) {
                logger.error(e.getMessage());
                return null;
            }
        }
    }

    private static class JsonSqlDateDeserializer extends JsonDeserializer<java.sql.Date> {

        @Override
        public java.sql.Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
            try {
                String dateString = jsonParser.getText();
                return new java.sql.Date(string2Date(dateString).getTime());
            } catch (Exception e) {
                logger.error(e.getMessage());
                return null;
            }
        }

    }

    private static class JsonDateTimestampDeserializer extends JsonDeserializer<Timestamp> {

        @Override
        public Timestamp deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
            try {
                String dateString = jsonParser.getText();
                return new Timestamp(string2Date(dateString).getTime());
            } catch (Exception e) {
                logger.error(e.getMessage());
                return null;
            }
        }

    }

    private static class JsonTimeDeserializer extends JsonDeserializer<Time> {

        @Override
        public Time deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
            try {
                String dateString = jsonParser.getText();
                return new Time(string2Date(dateString).getTime());
            } catch (Exception e) {
                logger.error(e.getMessage());
                return null;
            }
        }

    }

}
```

#### 9.4.获取`linux`系统磁盘使用率 

```java
import java.io.*;

/**
 * linux 下cpu 内存 磁盘 jvm的使用监控
 * @author avery_leo
 */
public class Diskspace {
	/**
	 * 获取cpu使用情况
	 * 
	 * @return
	 * @throws Exception
	 */
	public double getCpuUsage() throws Exception {
		double cpuUsed = 0;

		Runtime rt = Runtime.getRuntime();
		Process p = rt.exec("top -b -n 1");// 调用系统的“top"命令

		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String str = null;
			String[] strArray = null;

			while ((str = in.readLine()) != null) {
				int m = 0;

				if (str.indexOf(" R ") != -1) {// 只分析正在运行的进程，top进程本身除外 &&

					strArray = str.split(" ");
					for (String tmp : strArray) {
						if (tmp.trim().length() == 0)
							continue;
						if (++m == 9) {// 第9列为CPU的使用百分比(RedHat

							cpuUsed += Double.parseDouble(tmp);

						}

					}

				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			in.close();
		}
		return cpuUsed;
	}

	/**
	 * 内存监控
	 * 
	 * @return
	 * @throws Exception
	 */
	public double getMemUsage() throws Exception {

		double menUsed = 0;
		Runtime rt = Runtime.getRuntime();
		Process p = rt.exec("top -b -n 1");// 调用系统的“top"命令

		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String str = null;
			String[] strArray = null;

			while ((str = in.readLine()) != null) {
				int m = 0;

				if (str.indexOf(" R ") != -1) {// 只分析正在运行的进程，top进程本身除外 &&
				//
				// System.out.println("------------------3-----------------");
					strArray = str.split(" ");
					for (String tmp : strArray) {
						if (tmp.trim().length() == 0)
							continue;

						if (++m == 10) {
							// 9)--第10列为mem的使用百分比(RedHat 9)

							menUsed += Double.parseDouble(tmp);

						}
					}

				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			in.close();
		}
		return menUsed;
	}

	/**
	 * 获取磁盘空间大小
	 * 
	 * @return
	 * @throws Exception
	 */
	public double getDeskUsage() throws Exception {
		double totalHD = 0;
		double usedHD = 0;
		Runtime rt = Runtime.getRuntime();
		Process p = rt.exec("df -hl /home");// df -hl 查看硬盘空间

		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String str = null;
			String[] strArray = null;
			while ((str = in.readLine()) != null) {
				int m = 0;
				strArray = str.split(" ");
				for (String tmp : strArray) {
					if (tmp.trim().length() == 0)
						continue;
					++m;
					System.out.println("----tmp----" + tmp);
					if (tmp.indexOf("G") != -1) {
						if (m == 2) {
							System.out.println("---G----" + tmp);
							if (!tmp.equals("") && !tmp.equals("0"))
								totalHD += Double.parseDouble(tmp.substring(0,
										tmp.length() - 1)) * 1024;

						}
						if (m == 3) {
							System.out.println("---G----" + tmp);
							if (!tmp.equals("none") && !tmp.equals("0"))
								usedHD += Double.parseDouble(tmp.substring(0,
										tmp.length() - 1)) * 1024;

						}
					}
					if (tmp.indexOf("M") != -1) {
						if (m == 2) {
							System.out.println("---M---" + tmp);
							if (!tmp.equals("") && !tmp.equals("0"))
								totalHD += Double.parseDouble(tmp.substring(0,
										tmp.length() - 1));

						}
						if (m == 3) {
							System.out.println("---M---" + tmp);
							if (!tmp.equals("none") && !tmp.equals("0"))
								usedHD += Double.parseDouble(tmp.substring(0,
										tmp.length() - 1));
							System.out.println("----3----" + usedHD);
						}
					}

				}

			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			in.close();
		}
		// 上面写在userd和total写反了，懒得改了，就反着用了
		System.out.println("----totalHD----" + usedHD);
		System.out.println("----usedHD----" + totalHD);
		return (totalHD / usedHD) * 100;
	}

	public static void main(String[] args) throws Exception {
		DiskSpace cpu = new DiskSpace();
		System.out
				.println("---------------cpu used:" + cpu.getCpuUsage() + "%");
		System.out
				.println("---------------mem used:" + cpu.getMemUsage() + "%");
		System.out
				.println("---------------HD used:" + cpu.getDeskUsage() + "%");
		System.out.println("------------jvm监控----------------------");
		Runtime lRuntime = Runtime.getRuntime();
		System.out.println("--------------Free Momery:" + lRuntime.freeMemory()
				+ "K");
		System.out.println("--------------Max Momery:" + lRuntime.maxMemory()
				+ "K");
		System.out.println("--------------Total Momery:"
				+ lRuntime.totalMemory() + "K");
		System.out.println("---------------Available Processors :"
				+ lRuntime.availableProcessors());
	}
}
```

#### 9.5.代码文件添加`license`信息

```java
package com.upcwangying.app;

import java.io.*;

/**
 * @author WANGY
 * @date 2018-3-6 13:26
 */
public class Copyright {
    private static String lineSeperator = System.getProperty("line.separator");
    private static String encode = "UTF-8";

    private String folder;
    private String copyright;

    /**
     * @param folder    java文件夹
     * @param copyright 版权内容
     */
    public Copyright(String folder, String copyright) {
        this.folder = folder;
        this.copyright = copyright;
    }

    public static void main(String[] args) throws IOException {
        // 从文件读取版权内容
        // 在D盘创建一个copyright.txt文件,把版权内容放进去即可
        String copyright = readCopyrightFromFile("F:\\work\\work\\spring-boot-social-login\\copyright.txt");
        // 存放java文件的文件夹,必须是文件夹
        String folder = "F:\\work\\work\\spring-boot-social-login\\social-login-app\\src\\main\\java\\com\\upcwangying\\app\\test";

        new Copyright(folder, copyright).process();

        System.out.println("end.");
    }

    public void process() {
        this.addCopyright(new File(folder));
    }

    private void addCopyright(File folder) {
        File[] files = folder.listFiles();

        if (files == null || files.length == 0) {
            return;
        }

        for (File f : files) {
            if (f.isFile()) {
                doAddCopyright(f);
            } else {
                addCopyright(f);
            }
        }
    }

    private void doAddCopyright(File file) {
        String fileName = file.getName();
        boolean isJavaFile = fileName.toLowerCase().endsWith(".java");
        if (isJavaFile) {
            try {
                this.doWrite(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     *
     * @param file
     * @throws IOException
     */
    private void doWrite(File file) throws IOException {

        StringBuilder javaFileContent = new StringBuilder();
        String line = null;
        // 先添加copyright到文件头
        javaFileContent.append(copyright).append(lineSeperator);
        // 追加剩余内容
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), encode));
        while ((line = br.readLine()) != null) {
            javaFileContent.append(line).append(lineSeperator);
        }

        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), encode);
        writer.write(javaFileContent.toString());
        writer.close();
        br.close();
    }

    /**
     *
     * @param copyFilePath
     * @return
     * @throws IOException
     */
    private static String readCopyrightFromFile(String copyFilePath) throws IOException {
        StringBuilder copyright = new StringBuilder();

        String line = null;

        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(copyFilePath), encode));

        while ((line = br.readLine()) != null) {
            copyright.append(line).append(lineSeperator);
        }
        br.close();

        return copyright.toString();
    }
}
```



### 十、文件转`PDF`

#### 10.1.`execl`转`pdf`

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import com.aspose.cells.License;
import com.aspose.cells.SaveFormat;
import com.aspose.cells.Workbook;

import junit.framework.Test;

public class ExcelPdf {

	public static void main(String[] args) {
		excel2pdf("D://接受文件//s.xlsx");
		System.out.println("---------完成---------");
	}

	/**
	 * 协助excel转换的方法
	 * 验证License 若不验证则转化出的pdf文档会有水印产生
	 * @return
	 */
	public static boolean getLicense() {
		boolean result = false;
		try {
			InputStream is = Test.class.getClassLoader().getResourceAsStream("xlsxlicense.xml"); // license.xml应放在..\WebRoot\WEB-INF\classes路径下
			License aposeLic = new License();
			aposeLic.setLicense(is);
			result = true;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	/**
	 * excel转换pdf
	 * @param Address
	 */
	public static void excel2pdf(String Address) {
		if (!getLicense()) { // 验证License 若不验证则转化出的pdf文档会有水印产生
			return;
		}
		try {
			File pdfFile = new File("D://接受文件//s22222.pdf");// 输出路径
			Workbook wb = new Workbook(Address);// 原始excel路径
			FileOutputStream fileOS = new FileOutputStream(pdfFile);
			wb.save(fileOS, SaveFormat.PDF);
			fileOS.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}

```

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Iterator;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import com.itextpdf.text.Document;
import com.itextpdf.text.Font;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.PdfWriter;

/**
 * excel转换pdf
 * 使用全部语言
 * @author DH
 */
public class AllExcelPdf {

	public static void main(String[] args) {
		try {
			excelPdf("D://接受文件//s.xls", "D://接受文件//s22222.pdf");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("---------完成---------");
	}

	public static void excelPdf(String excelpath, String pdfFile) throws Exception {
		FileInputStream input_document = new FileInputStream(new File(excelpath));
		XSSFWorkbook my_xls_workbook = new XSSFWorkbook(input_document);
		XSSFSheet my_worksheet = my_xls_workbook.getSheetAt(0);
		Iterator<Row> rowIterator = my_worksheet.iterator();
		Document iText_xls_2_pdf = new Document();
		PdfWriter.getInstance(iText_xls_2_pdf, new FileOutputStream(pdfFile));
		iText_xls_2_pdf.open();
		int cells = my_worksheet.getRow(0).getPhysicalNumberOfCells();// 列数
		PdfPTable my_table = new PdfPTable(cells);

		PdfPCell table_cell;

		while (rowIterator.hasNext()) {
			Row row = rowIterator.next();
			Iterator<Cell> cellIterator = row.cellIterator();
			while (cellIterator.hasNext()) {
				Cell cell = cellIterator.next(); // Fetch CELL
				System.out.println("========="+cell);
				String str = cell.toString();
				BaseFont bfChinese = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);
				Font font = new Font(bfChinese, 10, Font.NORMAL);
				switch (cell.getCellType()) { // Identify CELL type
				case Cell.CELL_TYPE_STRING:
					Phrase phrase = new Phrase(cell.getStringCellValue(), font);
					table_cell = new PdfPCell(phrase);
					my_table.addCell(table_cell);
					break;
				default:
					Phrase phrase1 = new Phrase(str, font);

					table_cell = new PdfPCell(phrase1);
					my_table.addCell(table_cell);
					break;
				}
			}
		}
		iText_xls_2_pdf.add(my_table);
		iText_xls_2_pdf.close();
		input_document.close();
		System.out.println("---------完成---------");
	}
}

```

#### 10.2.`word`转`pdf`

```java
package test;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

import org.docx4j.convert.out.pdf.PdfConversion;
import org.docx4j.convert.out.pdf.viaXSLFO.Conversion;
import org.docx4j.convert.out.pdf.viaXSLFO.PdfSettings;
import org.docx4j.fonts.IdentityPlusMapper;
import org.docx4j.fonts.Mapper;
import org.docx4j.fonts.PhysicalFont;
import org.docx4j.fonts.PhysicalFonts;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;

/**
 * word转换pdf
 * 
 * @author DH
 *
 */
public class WordPdf {
	public static void main(String[] args) {
		wordPdf("D://接受文件//s.docx", "D://接受文件//s31.pdf");
		System.err.println("---------end---------");
	}

	public static int wordPdf(String FilePath, String pdfFile) {
		try {
			InputStream is = new FileInputStream(new File(FilePath));
			WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.load(is);
			List sections = wordMLPackage.getDocumentModel().getSections();
			for (int i = 0; i < sections.size(); i++) {	wordMLPackage.getDocumentModel().getSections().get(i).getPageDimensions().setHeaderExtent(3000);
			}
			Mapper fontMapper = new IdentityPlusMapper();
			PhysicalFont font = PhysicalFonts.getPhysicalFonts().get("Microsoft Yahei");
			fontMapper.getFontMappings().put("微软雅黑", font);
			wordMLPackage.setFontMapper(fontMapper);
			PdfSettings pdfSettings = new PdfSettings();
			PdfConversion conversion = new Conversion(wordMLPackage);
			OutputStream out = new FileOutputStream(new File(pdfFile));
			conversion.output(out, pdfSettings);
			return 0;
		} catch (Exception e) {
			e.printStackTrace();
			return -1;
		}
	}
}
```

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;

import com.aspose.words.Document;
import com.aspose.words.SaveFormat;

/**
 * word转换pdf
 */
public class WordPdf3 {
	public static void main(String[] args) {
		InputStream pdf = wordPdf("D://接受文件//s2.doc", "D://接受文件//s999931.pdf");
		System.err.println(pdf+"---------pdf---------");
	}

	public static InputStream wordPdf(String FilePath,String pdfFile) {
	        try {  
	            File file = new File(pdfFile); // 新建一个空白pdf文档  
	            FileOutputStream os = new FileOutputStream(file);  
	            Document doc = new Document(FilePath); // Address是将要被转化的word文档  
	            doc.save(os, SaveFormat.PDF);// 全面支持DOC, DOCX, OOXML, RTF HTML, OpenDocument, PDF,  
	                                         // EPUB, XPS, SWF 相互转换  
	        } catch (Exception e) {  
	            e.printStackTrace();  
	        }
			return null;  
	}	
}
```

```java
/**
 * 文件转换pdf,使用open office转换pdf，需要安装open office插件，并开启该服务
 * @param sourceFileName 文件路径
 * @param pdfFileName pdf路径
 */
public void createTransPdfTemFile(String bucketName,String sourceFileName,String pdfFileName){

    OpenOfficeConnection connection = null;

    try {

        //将源文件转换为pdf，并在本地保存
        // 1: 打开连接
        connection = new SocketOpenOfficeConnection("172.18.230.50",8100);
        connection.connect();

        DocumentConverter converter = new OpenOfficeDocumentConverter(connection);

        File sourceFile=new File(sourceFileName);
        File targetFile=new File(pdfFileName);

        converter.convert(sourceFile, targetFile);

    }catch (Exception e){
        e.printStackTrace();
    }finally {
        if(connection!=null&&connection.isConnected()){
            connection.disconnect();
        }
    }
}


/*
开启open office的命令：  
cd C:\Program Files (x86)\OpenOffice 4\program
soffice -headless -accept="socket,host=172.18.230.50,port=8100;urp;" -nofirststartwizard
telnet “IP”  8100
*/
```

#### 10.3.`Text`转`PDF`

```java
package test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;     
import java.io.FileReader;     
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.Font;
import com.itextpdf.text.PageSize;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.PdfWriter;



/**
 * 将txt转换程pdf并且加密
 * 
 * 
 */
public class TxtPdf {

	public static void main(String[] args) {
		String txtpath = "D://接受文件//ss.txt";
		String pdfpath = "D://接受文件//sss.pdf";
		try {
			txtPdf(txtpath, pdfpath);
			System.out.println("============执行成功！===========");
		} catch (DocumentException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void txtPdf(String txtpath, String pdfpath) throws DocumentException, IOException {
		Document document = new Document();
		PdfWriter.getInstance(document, new FileOutputStream(pdfpath));
		document.open();
		BaseFont bfChinese = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);
		Font FontChinese = new Font(bfChinese, 18, Font.NORMAL);
		Paragraph t = new Paragraph(readtxt(txtpath), FontChinese); 
		t.setAlignment(Element.ALIGN_CENTER);
		t.setLeading(30.0f);
		document.add(t);
		FontChinese = new Font(bfChinese, 11, Font.NORMAL);
		BufferedReader read = null;
		try {
			read = new BufferedReader(new FileReader(txtpath));
			String line = null;
			while ((line = read.readLine()) != null) {
				t = new Paragraph(line, FontChinese);
				t.setAlignment(Element.ALIGN_LEFT);
				t.setLeading(20.0f);
				document.add(t);
			}
		} catch (Exception e) {
			System.out.println("目标文件不存，或者不可读！");
			e.printStackTrace();
		} finally {
			try {
				read.close();
				document.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	public static String readtxt(String path) {
		String result = "";
		File file = new File(path);
		try {
			InputStreamReader reader = new InputStreamReader(new FileInputStream(file), "gbk");
			BufferedReader br = new BufferedReader(reader);
			String s = null;
			while ((s = br.readLine()) != null) {
				result = result + s;
			}
		} catch (UnsupportedEncodingException | FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}
}
```

### 十一、`FTP`

#### 11.1.`FTP`断点续传

```java
package file;

public enum FileStatus {
    Local_File_Not_exist("本地文件不存在", 0),

    Create_Directory_Fail("远程服务器相应目录创建失败", 1),

    Create_Directory_Success("远程服务器闯将目录成功", 2),

    Upload_New_File_Success("上传新文件成功", 3),

    Upload_New_File_Failed("上传新文件失败", 4),

    File_Exits("文件已经存在", 5),

    Remote_Bigger_Local("远程文件大于本地文件", 6),

    Upload_From_Break_Success("断点续传成功", 7),

    Upload_From_Break_Failed("断点续传失败", 8),

    Delete_Remote_Failed("删除远程文件失败", 9),

    Remote_File_Not_exist("远程文件不存在", 10),

    Local_Bigger_Remote("本地文件大于远程文件", 11),

    Download_From_Break_Success("断点下载文件成功", 12),

    Download_From_Break_Failed("断点下载文件失败", 13),

    Download_New_Success("全新下载文件成功", 14),

    Download_New_Failed("全新下载文件失败", 15);

    private String desc;
    private int index;

    private FileStatus(String desc, int index) {
        this.desc = desc;
        this.index = index;
    }

    public static String getDesc(int index) {
        for (FileStatus status : FileStatus.values()) {
            if (status.index == index) {
                return status.desc;
            }
        }
        return null;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public int getIndex() {
        return index;
    }

    public void setIndex(int index) {
        this.index = index;
    }
}
```

```java
package file;

import org.apache.commons.net.PrintCommandListener;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;

import java.io.*;

public class FileClient {

    private String host;
    private Integer port;
    private String username;
    private String password;
    private FTPClient ftpClient;
    private static String LOCAL_CHARSET = System.getProperty("file.encoding");
//    private static String LOCAL_CHARSET = "GBK";
    private static String SERVER_CHARSET = FTP.DEFAULT_CONTROL_ENCODING;

    public FileClient(String host, String username, String password) {
        this(host, 21, username, password);
    }

    public FileClient(String host, Integer port, String username, String password) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
        this.ftpClient = new FTPClient();
    }

    public void connect() {
        try {
            ftpClient.connect(host, port);
            if (!ftpClient.login(username, password)) {
                System.out.println("Failed to login");
            }
//            if (FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {
//                ftpClient.disconnect();
//                System.out.println("Connection error");
//            }
            System.out.println(ftpClient.isConnected());

            //TODO: Remove Debug, output ftp command
            ftpClient.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out)));
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * 上传文件
     *
     * @param localFile 本地文件名称（绝对路径表示）
     * @param remotePath 远程文件名称（绝对路径表示）
     * @return
     */
    public FileStatus upload(String localFile, String remotePath) {
        FileStatus result;
        File file = new File(localFile);
        if (!file.exists()) {
            System.out.println("file not exists");
            return FileStatus.Local_File_Not_exist;
        }
        if (!ftpClient.isConnected()) {
            System.out.println("Client not connected");
            return null;
        }
        try {
            ftpClient.enterLocalPassiveMode();
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            ftpClient.setControlEncoding(LOCAL_CHARSET);

            String remoteDir = new String(remotePath.getBytes(LOCAL_CHARSET), FTP.DEFAULT_CONTROL_ENCODING);
            String remoteFileName = remoteDir;
            if(remoteDir.contains("/")) {
                remoteFileName = remoteDir.substring(remoteDir.lastIndexOf("/") + 1);
            }

            if (!ftpClient.changeWorkingDirectory(remoteDir)) {
                if (createMultiDirectory(ftpClient, remoteDir) != FileStatus.Create_Directory_Success && !ftpClient.changeWorkingDirectory(remoteDir)) {
                    System.out.println("Filed to create & enter file directory");
                }
            }

            //检查远程是否存在文件
            FTPFile[] files = ftpClient.listFiles(remoteFileName);
            if(files.length == 1) {
                long remoteSize = files[0].getSize();
                File f = new File(localFile);
                long localSize = f.length();
                if (remoteSize == localSize) {
                    return FileStatus.File_Exits;
                } else if (remoteSize > localSize) {
                    return FileStatus.Remote_Bigger_Local;
                }
                FileStatus status = uploadFile(remoteFileName, file, remoteSize);
                if (status == FileStatus.Upload_From_Break_Failed) {
                    if(!ftpClient.deleteFile(remoteFileName)){
                        return FileStatus.Delete_Remote_Failed;
                    }
                    result = uploadFile(remoteFileName, file, 0);
                } else {
                    result = uploadFile(remoteFileName, file, 0);
                }
                return result;
            }

            InputStream inputStream = new FileInputStream(file);

            OutputStream outputStream = ftpClient.storeFileStream(remoteDir);
            byte[] bytesIn = new byte[4096];
            int read = 0;

            while ((read = inputStream.read(bytesIn)) != -1) {
                outputStream.write(bytesIn, 0, read);
            }
            inputStream.close();
            outputStream.close();
            boolean completed = ftpClient.completePendingCommand();
            if (completed) {
                System.out.println("The file is uploaded successfully.");
            }
            return FileStatus.Upload_New_File_Success;
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            System.out.println("unsupported encoding");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return FileStatus.Upload_New_File_Failed;
    }

    private FileStatus uploadFile(String remotePath, File localFile, long remoteSize) {
        FileStatus status;
        long step = localFile.length();
        long process = 0;
        long readedByte = 0L;
        try {
            RandomAccessFile randomAccessFile = new RandomAccessFile(localFile,"r");
            OutputStream out = ftpClient.appendFileStream(remotePath);
            //服务端已经存在文件（断点续传）
            if(remoteSize>0){
                ftpClient.setRestartOffset(remoteSize);
                process = remoteSize /step;
                randomAccessFile.seek(remoteSize);
                readedByte = remoteSize;
            }
            byte[] bytes = new byte[1024];
            int b;
            while((b = randomAccessFile.read(bytes))!= -1) {
                out.write(bytes, 0, b);
                readedByte += b;
                if (readedByte / step != process) {
                    process = readedByte / step;
                    System.out.println("上传进度:" + process);
                }
            }
            out.flush();
            randomAccessFile.close();
            out.close();
            boolean result =ftpClient.completePendingCommand();
            if(remoteSize > 0){
                status = result?FileStatus.Upload_From_Break_Success:FileStatus.Upload_From_Break_Failed;
            }else {
                status = result?FileStatus.Upload_New_File_Success:FileStatus.Upload_New_File_Failed;
            }
            return status;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return remoteSize > 0 ? FileStatus.Upload_From_Break_Failed : FileStatus.Upload_New_File_Failed;
    }

    public FileStatus download(String remotePath, String localPath) {
        FileStatus status;
        boolean breakPoint = false;
        try {
            ftpClient.enterLocalPassiveMode();
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            FTPFile[] files = ftpClient.listFiles(new String(remotePath.getBytes(LOCAL_CHARSET), SERVER_CHARSET));
            if(files.length != 1){
                System.out.println("远程文件不存在");
                return FileStatus.Remote_File_Not_exist;
            }

            long lRemoteSize = files[0].getSize();
            File file = new File(localPath);
            FileOutputStream out;
            InputStream in;
            byte[] bytes = new byte[1024];

            double process = 0;
            long localSize = 0L;
            int c;

            //本地存在文件，进行断点下载
            if(file.exists()) {
                breakPoint = true;
                localSize = file.length();
                if (localSize >= lRemoteSize) {
                    System.out.println("本地文件大于远程文件，下载中止");
                    return FileStatus.Local_Bigger_Remote;
                }
                out = new FileOutputStream(file,true);
                ftpClient.setRestartOffset(localSize);
                process = localSize / lRemoteSize;
            } else { //新的下载
                out = new FileOutputStream(file);
            }
            in = ftpClient.retrieveFileStream(new String(remotePath.getBytes(LOCAL_CHARSET), SERVER_CHARSET));
            while ((c = in.read(bytes)) != -1) {
                out.write(bytes, 0, c);
                localSize += c;
                process = localSize / lRemoteSize;
            }
            in.close();
            out.close();
            boolean upNewStatus = ftpClient.completePendingCommand();
            if(upNewStatus){
                status = FileStatus.Download_New_Success;
            }else {
                status = FileStatus.Download_New_Failed;
            }
            return status;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return breakPoint ? FileStatus.Download_New_Failed : FileStatus.Download_From_Break_Failed;
    }

    /**
     * 创建多级目录
     *
     * @param ftpClient
     * @param multiDirectory
     * @return
     */
    private FileStatus createMultiDirectory(FTPClient ftpClient, String multiDirectory) {
        if (!multiDirectory.startsWith("/")) {
            multiDirectory = "/" + multiDirectory;
        }
        String directory = multiDirectory.substring(0, multiDirectory.lastIndexOf("/")+1);
        try {
            if (!directory.equalsIgnoreCase("/") && !ftpClient.changeWorkingDirectory(directory)) {
                try {
                    String[] dirs = directory.split("/");
                    ftpClient.changeWorkingDirectory("/");
                    //按顺序检查目录是否存在，不存在则创建目录
                    for(int i=1; i<dirs.length; i++) {
                        if (dirs[i].isEmpty())
                            continue;
//                        String subDirectory = new String(dirs[i].getBytes(LOCAL_CHARSET), SERVER_CHARSET);
                        String subDirectory = dirs[i];
                        if(!ftpClient.changeWorkingDirectory(subDirectory)) {
                            if(ftpClient.makeDirectory(subDirectory)) {
                                if(!ftpClient.changeWorkingDirectory(subDirectory)) {
                                    return FileStatus.Create_Directory_Fail;
                                }
                            }else {
                                return FileStatus.Create_Directory_Fail;
                            }
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println("Failed to create file directory");
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
            return FileStatus.Create_Directory_Fail;
        }
        return FileStatus.Create_Directory_Success;
    }

    private void disconnect() throws IOException {
        if (ftpClient.isConnected()) {
            ftpClient.disconnect();
        }
    }

    public static void main(String[] args) throws IOException {
        FileClient client = new FileClient("localhost", "transmitter", "0zxtxbQd*B31");
        client.connect();

        FileStatus status = client.upload("/Users/me/中文文件.txt", "/呵呵/中/中文文件.txt");
        System.out.println(status);
        status = client.download("/呵呵/中/中文文件.txt", "/Users/me/download233.txt");
        System.out.println(status);
        client.disconnect();
    }
}
```


