[^1]: https://juejin.im/post/5c9a67ac6fb9a070cb24bf34?utm_source=gold_browser_extension
[^2]: <https://blog.csdn.net/zhengzhaoyang122/article/details/82184029>



# 一、缓存穿透

正常情况下，我们查询的数据是存在的。但是当请求查询的数据不存在时，在缓存和数据库中都查询不到这条数据，但是请求都打到了数据库上的这种现象叫做**缓存穿透**。

导致的问题：若黑客对系统进行攻击，使用一个不存在的`id`区查询数据，会产生大量的请求到数据库查询，从而可能导致数据库压力过大而宕机。

缓存穿透的原因：缓存中没有存储这些空数据的`key`，从而导致每次查询都到数据库了。

## 1.1.解决方案

### 1.1.1.缓存空值

对这些`key`对应的值设置为`null`丢到缓存中，后面再次查询这个`key`的请求时，直接返回`null`，这样就不再会每次在数据库中查询。但注意要给缓存设置过期时间。

### 1.1.2.`BloomFilter`





# 二、缓存击穿

在高并发系统中，大量请求同时查询一个`key`，但是这个`key`刚好失效，就会导致大量的请求都打到了数据库上，这种现象叫做**缓存击穿**。

导致的问题：可能会造成某一时刻数据库请求过大，压力剧增。

## 2.1.解决方案

多线程同时去查询数据库的这条数据，可以在第一查询数据的请求上使用互斥锁来锁住它。

其它线程走到此部拿不到锁就等着，等第一个线程查询到数据并缓存后，后面的线程发现有缓存了，就直接做缓存。



# 三、缓存雪崩

当某一时刻大规模的缓存失效的情况，比如缓存服务器宕机，导致大量的请求进来直接打到`DB`上，导致数据库撑不住而挂掉。

## 3.1.解决方案

事前准备：

- **使用集群缓存，保证缓存服务的高可用；**如使用`Redis`主从+哨兵，`Redis Cluster`来避免`Redis`全盘崩溃情况。

事中准备：

- **`ehcache`本地缓存+`Hystrix`限流`&`降级，避免`MySQL`被打死**。
- 使用`ehcache`本地缓存目的是考虑在`Redis Cluster`完全不可用时，`ehcache`本地缓存支撑一阵。

- 使用`Hystrix`进行限流`&`降级，可以在一秒来了5000个请求，我们可以设置假设只能有一秒2000个请求能通过这个组件，那么其他剩余的3000请求就会走限流逻辑，然后去调用我们自己开发的降级组件（降级），如设置一些默认值。从而保护数据库不被大量的请求打死。

事后准备：

- **开启`Redis`的持久化机制，尽快恢复缓存集群。**
- 一旦重启后，能快速的从磁盘加载数据恢复到内存。

![img](../images/169bb265aa52e948-1553674277928)



# 四、缓冲集中失效问题

对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

## 4.1.解决方案

### 4.1.1.设置不同的失效时间

为了避免这些热点数据集中失效，我们可以设置缓存过期时间，让它们的失效时间错开。

比如在一个基础的时间上加上或减去一个范围内的随机值。

### 4.1.2.互斥锁

击穿的情况，在第一次请求区查询数据库时，对它加一个互斥锁，其余的查询请求都会被阻塞，直到锁被释放，从而保护数据库。

但是由于它会阻塞其它线程，此时的系统会吞吐量下降，所以实际业务中要考虑是否这样做。



