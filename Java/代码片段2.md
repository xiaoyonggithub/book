### 二、排序算法

#### 2.1.快速排序

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] arr = new int[]{5,2,6,1,7,4,9,8,3};
        sort(arr,0,arr.length);
        for(int i:arr){
            System.out.print(i+" ");
        }
    }


    public static void sort(int[] arr,int start,int end){
        if(start>=end) return ;
        int p_index = p_index(arr, start, end);
        sort(arr,start,p_index);
        sort(arr,p_index+1,end);
    }

    public static int p_index(int[] arr,int start,int end){
        int p_index = start;
        int p_value = arr[start];

        for(int i=start+1;i<end;i++){
            if(arr[i]<p_value){
                p_index ++;
                if(p_index!=i){
                    int tmp = arr[i];
                    arr[i] = arr[p_index];
                    arr[p_index] = tmp;
                }
            }

        }
        int tmp = arr[p_index];
        arr[p_index] = arr[start];
        arr[start] = tmp;
        return p_index;
    }
}
```

### 三、二维码

#### 3.1.二维码的生成与解析`(zxing)`

```xml
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>core</artifactId>
    <version>3.3.2</version>
</dependency>
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>javase</artifactId>
    <version>3.3.2</version>
</dependency>
```

```java
//生成二维码
//String url = "14523";    //字符
//int width = 100;         //二维码的宽度
//int height = 100;        //二维码的高度
public void writeQRCode(String url,int width,int height){
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
        MultiFormatWriter writer = new MultiFormatWriter();
        Map<EncodeHintType, Object> hints = new HashMap<>();
        //设置生成的二维码的格式
        hints.put(EncodeHintType.CHARACTER_SET, "utf-8");
        BitMatrix bitMatrix = writer.encode(url, BarcodeFormat.QR_CODE, width,height, hints);
        MatrixToImageWriter.writeToStream(bitMatrix, "png", out);
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException("生成二维码出错", e);
    }
    //将生成的二维码64bit编码，然后再前台展示。
    System.out.println(Base64Utils.encodeToString(out.toByteArray()));
}
```

```java
//解析生成的二维码
public void readQRCOde() throws Exception{
    MultiFormatReader reader = new MultiFormatReader();
    BufferedImage bufferImage = 			              ImageIO.read(QRCodeTest.class.getClassLoader().getResourceAsStream("code.png"));
    //需要读取图片，并传入一个图片信息解析类
    Binarizer binarizer = new HybridBinarizer(new BufferedImageLuminanceSource(bufferImage));
    BinaryBitmap image = new BinaryBitmap(binarizer);
    //设置二维码的解码格式
    Map<DecodeHintType, String> hints = new HashMap<>();
    hints.put(DecodeHintType.CHARACTER_SET, "utf-8");

    //解析出二维码的内容
    Result result = reader.decode(image,hints);

    System.out.println(result);
    System.out.println("------------------------------------------");
    //二维码条形码格式
    System.out.println(result.getBarcodeFormat());
    System.out.println("------------------------------------------");
    //二维码的字符
    System.out.println(result.getText());  
}
```

```java
import java.awt.Graphics2D;  
import java.awt.geom.AffineTransform;  
import java.awt.image.BufferedImage;  
import java.io.File;  
import java.io.IOException;  
import java.io.OutputStream;  
import java.util.HashMap;  
import java.util.Hashtable;  
import java.util.Map;  
import javax.imageio.ImageIO;  
import javax.servlet.http.HttpServletResponse;  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import com.google.zxing.BarcodeFormat;  
import com.google.zxing.Binarizer;  
import com.google.zxing.BinaryBitmap;  
import com.google.zxing.DecodeHintType;  
import com.google.zxing.EncodeHintType;  
import com.google.zxing.LuminanceSource;  
import com.google.zxing.MultiFormatReader;  
import com.google.zxing.MultiFormatWriter;  
import com.google.zxing.Result;  
import com.google.zxing.common.BitMatrix;  
import com.google.zxing.common.HybridBinarizer;  
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;  
  
/** 
 * <p>Title:QRCodeUtil </p> 
 * <p>Description: 二维码生成工具类</p> 
 * @author Administrator 
 * @version  
 * @since  
 */  
public final class QRCodeUtil extends LuminanceSource {  
  
    private static final Logger logger = LoggerFactory.getLogger(QRCodeUtil.class);  
  
    // 二维码颜色  
    private static final int BLACK = 0xFF000000;  
    // 二维码颜色  
    private static final int WHITE = 0xFFFFFFFF;  
  
    private final BufferedImage image;  
    private final int left;  
    private final int top;  
  
    public QRCodeUtil(BufferedImage image) {  
        this(image, 0, 0, image.getWidth(), image.getHeight());  
    }  
  
    public QRCodeUtil(BufferedImage image, int left, int top, int width, int height) {  
        super(width, height);  
        int sourceWidth = image.getWidth();  
        int sourceHeight = image.getHeight();  
        if (left + width > sourceWidth || top + height > sourceHeight) {  
            throw new IllegalArgumentException("Crop rectangle does not fit within image data.");  
        }  
        for (int y = top; y < top + height; y++) {  
            for (int x = left; x < left + width; x++) {  
                if ((image.getRGB(x, y) & 0xFF000000) == 0) {  
                    image.setRGB(x, y, 0xFFFFFFFF); // = white  
                }  
            }  
        }  
        this.image = new BufferedImage(sourceWidth, sourceHeight, BufferedImage.TYPE_BYTE_GRAY);  
        this.image.getGraphics().drawImage(image, 0, 0, null);  
        this.left = left;  
        this.top = top;  
    }  
  
    @Override  
    public byte[] getRow(int y, byte[] row) {  
        if (y < 0 || y >= getHeight()) {  
            throw new IllegalArgumentException("Requested row is outside the image: " + y); 
        }  
        int width = getWidth();  
        if (row == null || row.length < width) {  
            row = new byte[width];  
        }  
        image.getRaster().getDataElements(left, top + y, width, 1, row);  
        return row;  
    }  
  
    @Override  
    public byte[] getMatrix() {  
        int width = getWidth();  
        int height = getHeight();  
        int area = width * height;  
        byte[] matrix = new byte[area];  
        image.getRaster().getDataElements(left, top, width, height, matrix);  
        return matrix;  
    }  
  
    @Override  
    public boolean isCropSupported() {  
        return true;  
    }  
  
    @Override  
    public LuminanceSource crop(int left, int top, int width, int height) {  
        return new QRCodeUtil(image, this.left + left, this.top + top, width, height);  
    }  
  
    @Override  
    public boolean isRotateSupported() {  
        return true;  
    }  
  
    @Override  
    public LuminanceSource rotateCounterClockwise() {  
        int sourceWidth = image.getWidth();  
        int sourceHeight = image.getHeight();  
        AffineTransform transform = new AffineTransform(0.0, -1.0, 1.0, 0.0, 0.0, sourceWidth);  
        BufferedImage rotatedImage = new BufferedImage(sourceHeight, sourceWidth, BufferedImage.TYPE_BYTE_GRAY);  
        Graphics2D g = rotatedImage.createGraphics();  
        g.drawImage(image, transform, null);  
        g.dispose();  
        int width = getWidth();  
        return new QRCodeUtil(rotatedImage, top, sourceWidth - (left + width), getHeight(), width);  
    }  
  
    /** 
     * @param matrix 
     * @return 
     */  
    private static BufferedImage toBufferedImage(BitMatrix matrix) {  
        int width = matrix.getWidth();  
        int height = matrix.getHeight();  
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);  
        for (int x = 0; x < width; x++) {  
            for (int y = 0; y < height; y++) {  
                image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE);  
            }  
        }  
        return image;  
    }  
  
    /** 
     * 生成二维码图片 
     * @param matrix 
     * @param format 
     * @param file 
     * @throws IOException 
     */  
    public static void writeToFile(BitMatrix matrix, String format, File file) throws IOException {  
        BufferedImage image = toBufferedImage(matrix);  
        if (!ImageIO.write(image, format, file)) {  
            throw new IOException("Could not write an image of format " + format + " to " + file);  
        }  
    }  
  
    /** 
     * 生成二维码图片流 
     * @param matrix 
     * @param format 
     * @param stream 
     * @throws IOException 
     */  
    public static void writeToStream(BitMatrix matrix, String format, OutputStream stream) throws IOException {  
        BufferedImage image = toBufferedImage(matrix);  
        if (!ImageIO.write(image, format, stream)) {  
            throw new IOException("Could not write an image of format " + format);  
        }  
    }  
  
    /** 
     * 根据内容，生成指定宽高、指定格式的二维码图片 
     * @param text   内容 
     * @param width  宽 
     * @param height 高 
     * @param format 图片格式 
     * @return 生成的二维码图片路径 
     * @throws Exception 
     */  
    private static String generateQRCode(String text, int width, int height, String format, String pathName)  throws Exception {  
        Hashtable<EncodeHintType, Object> hints = new Hashtable<EncodeHintType, Object>();  
        hints.put(EncodeHintType.CHARACTER_SET, "utf-8");// 指定编码格式  
        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);// 指定纠错等级  
        hints.put(EncodeHintType.MARGIN, 1); // 白边大小，取值范围0~4  
        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);  
        File outputFile = new File(pathName);  
        writeToFile(bitMatrix, format, outputFile);  
        return pathName;  
    }  
  
    /** 
     * 输出二维码图片流 
     * @param text 二维码内容 
     * @param width 二维码宽 
     * @param height 二维码高 
     * @param format 图片格式eg: png, jpg, gif 
     * @param response HttpServletResponse 
     * @throws Exception 
     */  
    public static void generateQRCode(String text, int width, int height, String format, HttpServletResponse response)  
            throws Exception {  
        Hashtable<EncodeHintType, Object> hints = new Hashtable<EncodeHintType, Object>();  
        hints.put(EncodeHintType.CHARACTER_SET, "utf-8");// 指定编码格式  
        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);// 指定纠错等级  
        hints.put(EncodeHintType.MARGIN, 1); // 白边大小，取值范围0~4  
        BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints);  
        writeToStream(bitMatrix, format, response.getOutputStream());  
    }  
  
    /** 
     * 解析指定路径下的二维码图片 
     * @param filePath 二维码图片路径 
     * @return 
     */  
    public static String parseQRCode(String filePath) {  
        String content = "";  
        try {  
            File file = new File(filePath);  
            BufferedImage image = ImageIO.read(file);  
            LuminanceSource source = new QRCodeUtil(image);  
            Binarizer binarizer = new HybridBinarizer(source);  
            BinaryBitmap binaryBitmap = new BinaryBitmap(binarizer);  
            Map<DecodeHintType, Object> hints = new HashMap<DecodeHintType, Object>();  
            hints.put(DecodeHintType.CHARACTER_SET, "UTF-8");  
            MultiFormatReader formatReader = new MultiFormatReader();  
            Result result = formatReader.decode(binaryBitmap, hints);  
  
            logger.info("result 为：" + result.toString());  
            logger.info("resultFormat 为：" + result.getBarcodeFormat());  
            logger.info("resultText 为：" + result.getText());  
            // 设置返回值  
            content = result.getText();  
        } catch (Exception e) {  
            logger.error(e.getMessage());  
        }  
        return content;  
    }  
  
    public static void main(String[] args) {  
        String text = "hello world!"; // 随机生成验证码  
        System.out.println("随机码： " + text);  
        int width = 100; // 二维码图片的宽  
        int height = 100; // 二维码图片的高  
        String format = "png"; // 二维码图片的格式  
  
        try {  
            // 生成二维码图片，并返回图片路径  
            String pathName = generateQRCode(text, width, height, format, "D:/new.png");  
            System.out.println("生成二维码的图片路径： " + pathName);  
  
            String content = parseQRCode(pathName);  
            System.out.println("解析出二维码的图片的内容为： " + content);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
  
}  
```

#### 3.2.`QRCode`方式

```java
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

import javax.imageio.ImageIO;

import jp.sourceforge.qrcode.QRCodeDecoder;
import jp.sourceforge.qrcode.data.QRCodeImage;
import jp.sourceforge.qrcode.exception.DecodingFailedException;

import com.swetake.util.Qrcode;

//QRCode方式
public class QRCodeUtils {
	/**
	 * 编码字符串内容到目标File对象中
	 * @param encodeddata 编码的内容
	 * @param destFile	生成file文件  1381090722   5029067275903
	 * @throws IOException
	 */
	public static void qrCodeEncode(String encodeddata, File destFile) throws IOException {
		Qrcode qrcode = new Qrcode();
		qrcode.setQrcodeErrorCorrect('M');	// 纠错级别（L 7%、M 15%、Q 25%、H 30%）和版本有关
		qrcode.setQrcodeEncodeMode('B');	
		qrcode.setQrcodeVersion(7);		// 设置Qrcode包的版本
		
		byte[] d = encodeddata.getBytes("GBK");	// 字符集
		BufferedImage bi = new BufferedImage(139, 139, BufferedImage.TYPE_INT_RGB);
		// createGraphics	// 创建图层
		Graphics2D g = bi.createGraphics();
		
		g.setBackground(Color.WHITE);	// 设置背景颜色（白色）
		g.clearRect(0, 0, 139, 139);	// 矩形 X、Y、width、height
		g.setColor(Color.BLACK);	// 设置图像颜色（黑色）

		if (d.length > 0 && d.length < 123) {
			boolean[][] b = qrcode.calQrcode(d);
			for (int i = 0; i < b.length; i++) {
				for (int j = 0; j < b.length; j++) {
					if (b[j][i]) {
						g.fillRect(j * 3 + 2, i * 3 + 2, 3, 3);
					}
				}
			}
		}
		
//		Image img = ImageIO.read(new File("D:/tt.png"));  logo
//		g.drawImage(img, 25, 55,60,50, null);
				
		g.dispose(); // 释放此图形的上下文以及它使用的所有系统资源。调用 dispose 之后，就不能再使用 Graphics 对象
		bi.flush(); // 刷新此 Image 对象正在使用的所有可重构的资源

		ImageIO.write(bi, "png", destFile);
		System.out.println("Input Encoded data is：" + encodeddata);
	}

	/**
	 * 解析二维码，返回解析内容
	 * @param imageFile
	 * @return
	 */
	public static String qrCodeDecode(File imageFile) {
		String decodedData = null;
		QRCodeDecoder decoder = new QRCodeDecoder();
		BufferedImage image = null;
		try {
			image = ImageIO.read(imageFile);
		} catch (IOException e) {
			System.out.println("Error: " + e.getMessage());
		}

		try {
			decodedData = new String(decoder.decode(new J2SEImage(image)), "GBK");
			System.out.println("Output Decoded Data is：" + decodedData);
		} catch (DecodingFailedException dfe) {
			System.out.println("Error: " + dfe.getMessage());
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return decodedData;
	}

	public static void main(String[] args) {
		String FilePath = "d:/qrcode.png";
		File qrFile = new File(FilePath);

		// 二维码内容
		String encodeddata = "Hello X-rapido";
		try {
			QRCodeUtils.qrCodeEncode(encodeddata, qrFile);
		} catch (IOException e) {
			e.printStackTrace();
		}

		// 解码
		String reText = QRCodeUtils.qrCodeDecode(qrFile);
		System.out.println(reText);
	}
}

class J2SEImage implements QRCodeImage {
	BufferedImage image;

	public J2SEImage(BufferedImage image) {
		this.image = image;
	}

	public int getWidth() {
		return image.getWidth();
	}

	public int getHeight() {
		return image.getHeight();
	}

	public int getPixel(int x, int y) {
		return image.getRGB(x, y);
	}
}
```



### 四、数据库

#### 4.1.`c3p0 `连接和释放数据库

配置文件`（c3p0-config.xml） `

```xml
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <!--c3p0连接池配置文件-->
    <default-config>
        <property name="driverClass">com.mysql.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql:///jdbctest</property>
        <property name="user">root</property>
        <property name="password">root</property>
        <!--初始化时生成的连接数-->
        <property name="initialPoolSize">5</property>
        <!--最大连接数-->
        <property name="maxPoolSize">20</property>
    </default-config>
</c3p0-config>
```

```java
public class JDBCDataSourceUtils {
    private static ComboPooledDataSource dataSource = new ComboPooledDataSource();

    /**
     * 获得数据库连接
     * @return Connection 数据库连接对象
     */
    public static Connection getConnection() throws SQLException, ClassNotFoundException {
        Connection connection =  dataSource.getConnection();
        return connection;
    }

    /**
     * 资源释放方法，释放Statement 与 Connection
     * @param stmt
     * @param conn
     */
    public static void release(Statement stmt,Connection conn){
        if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            stmt = null;
        }

        if(conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            conn = null;
        }
    }

    /**
     *资源释放方法，释放Statement , Connection 与 ResultSet
     * @param rs
     * @param stmt
     * @param conn
     */
    public static void release( ResultSet rs,Statement stmt, Connection conn){
        if(rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            rs = null;
        }

        if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            stmt = null;
        }

        if(conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            conn = null;
        }
    }
}
```

#### 4.2.`jdbc`获取表结构 

```java
public void getTableDesc(){
    //1. JDBC连接MYSQL的代码很标准。 
    class.forName("com.mysql.jdbc.Driver").newInstance(); 
    Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/test?user=root&password=123456");

    //2. 下面就是获取表的信息。 
    m_DBMetaData = m_Connection.getMetaData(); 
    /*其中"%"就是表示*的意思，也就是任意所有的意思。其中m_TableName就是要获取的数据表的名字，如果想获取所有的表的名字，就可以使用"%"来作为参数了。*/
    ResultSet tableRet = m_DBMetaData.getTables(null, "%",m_TableName,new String[]{"TABLE"}); 
 
    //3. 提取表的名字。 
    while(tableRet.next) System.out.println(tableRet.getString("TABLE_NAME"));

    /*通过getString("TABLE_NAME")，就可以获取表的名字了。 
    从这里可以看出，前面通过getTables的接口的返回，JDBC是将其所有的结果，保存在一个类似table的内存结构中，而其中TABLE_NAME这个名字的字段就是每个表的名字。*/

    //4. 提取表内的字段的名字和类型 
    String columnName; 
    String columnType; 
    ResultSet colRet = m_DBMetaData.getColumns(null,"%", m_TableName,"%"); 
    while(colRet.next()) { 
      columnName = colRet.getString("COLUMN_NAME"); 
      columnType = colRet.getString("TYPE_NAME"); 
      int datasize = colRet.getInt("COLUMN_SIZE"); 
      int digits = colRet.getInt("DECIMAL_DIGITS"); 
      int nullable = colRet.getInt("NULLABLE"); 
      System.out.println(columnName+" "+columnType+" "+datasize+" "+digits+" "+ nullable); 
    }
}

/*JDBC里面通过getColumns的接口，实现对字段的查询。跟getTables一样，"%"表示所有任意的（字段），而m_TableName就是数据表的名字。

getColumns的返回也是将所有的字段放到一个类似的内存中的表，而COLUMN_NAME就是字段的名字，
TYPE_NAME就是数据类型，比如"int","int unsigned"等等，COLUMN_SIZE返回整数，就是字段的长度，
比如定义的int(8)的字段，返回就是8，最后NULLABLE，返回1就表示可以是Null,而0就表示Not Null。*/

```

```
/**更多列描述**/
TABLE_CAT String => 表类别（可为 null） 
TABLE_SCHEM String => 表模式（可为 null） 
TABLE_NAME String => 表名称 
COLUMN_NAME String => 列名称 
DATA_TYPE int => 来自 java.sql.Types 的 SQL 类型 
TYPE_NAME String => 数据源依赖的类型名称，对于 UDT，该类型名称是完全限定的 
COLUMN_SIZE int => 列的大小。 
BUFFER_LENGTH 未被使用。 
DECIMAL_DIGITS int => 小数部分的位数。对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。 
NUM_PREC_RADIX int => 基数（通常为 10 或 2） 
NULLABLE int => 是否允许使用 NULL。 
columnNoNulls - 可能不允许使用 NULL 值 
columnNullable - 明确允许使用 NULL 值 
columnNullableUnknown - 不知道是否可使用 null 
REMARKS String => 描述列的注释（可为 null） 
COLUMN_DEF String => 该列的默认值，当值在单引号内时应被解释为一个字符串（可为 null） 
SQL_DATA_TYPE int => 未使用 
SQL_DATETIME_SUB int => 未使用 
CHAR_OCTET_LENGTH int => 对于 char 类型，该长度是列中的最大字节数 
ORDINAL_POSITION int => 表中的列的索引（从 1 开始） 
IS_NULLABLE String => ISO 规则用于确定列是否包括 null。 
YES --- 如果参数可以包括 NULL 
NO --- 如果参数不可以包括 NULL 
空字符串 --- 如果不知道参数是否可以包括 null 
SCOPE_CATLOG String => 表的类别，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SCOPE_SCHEMA String => 表的模式，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SCOPE_TABLE String => 表名称，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 null） 
SOURCE_DATA_TYPE short => 不同类型或用户生成 Ref 类型、来自 java.sql.Types 的 SQL 类型的源类型
（如果 DATA_TYPE 不是 DISTINCT 或用户生成的 REF，则为 null） 
IS_AUTOINCREMENT String => 指示此列是否自动增加 
YES --- 如果该列自动增加 
NO --- 如果该列不自动增加 
空字符串 --- 如果不能确定该列是否是自动增加参数 
COLUMN_SIZE 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。
对于日期时间数据类型，这是 String 表示形式的字符长度（假定允许的最大小数秒组件的精度）。
对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 
```

### 五、日期

#### 5.1.日期的转化

```java
import org.apache.commons.lang3.time.DateFormatUtils;  
  
import java.text.ParseException;  
import java.text.SimpleDateFormat;  
import java.util.Calendar;  
import java.util.Date;  
public class DateUtils extends org.apache.commons.lang3.time.DateUtils{
	private static String[] parsePatterns = {  
            "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM",  
            "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM",  
            "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"};  
  
    /** 
     * 得到当前日期字符串 格式（yyyy-MM-dd） 
     */  
    public static String getDate() {  
        return getDate("yyyy-MM-dd");  
    }  
  
    /** 
     * 得到当前日期字符串 格式（yyyy-MM-dd） pattern可以为："yyyy-MM-dd" "HH:mm:ss" "E" 
     */  
    public static String getDate(String pattern) {  
        return DateFormatUtils.format(new Date(), pattern);  
    }  
  
    /** 
     * 得到日期字符串 默认格式（yyyy-MM-dd） pattern可以为："yyyy-MM-dd" "HH:mm:ss" "E" 
     */  
    public static String formatDate(Date date, Object... pattern) {  
        if (date == null) {  
            return null;  
        }  
        String formatDate = null;  
        if (pattern != null && pattern.length > 0) {  
            formatDate = DateFormatUtils.format(date, pattern[0].toString());  
        } else {  
            formatDate = DateFormatUtils.format(date, "yyyy-MM-dd");  
        }  
        return formatDate;  
    }  
  
    /** 
     * 得到日期时间字符串，转换格式（yyyy-MM-dd HH:mm:ss） 
     */  
    public static String formatDateTime(Date date) {  
        return formatDate(date, "yyyy-MM-dd HH:mm:ss");  
    }  
  
    /** 
     * 得到当前时间字符串 格式（HH:mm:ss） 
     */  
    public static String getTime() {  
        return formatDate(new Date(), "HH:mm:ss");  
    }  
  
    /** 
     * 得到当前日期和时间字符串 格式（yyyy-MM-dd HH:mm:ss） 
     */  
    public static String getDateTime() {  
        return formatDate(new Date(), "yyyy-MM-dd HH:mm:ss");  
    }  
  
    /** 
     * 得到当前年份字符串 格式（yyyy） 
     */  
    public static String getYear() {  
        return formatDate(new Date(), "yyyy");  
    }  
  
    /** 
     * 得到当前月份字符串 格式（MM） 
     */  
    public static String getMonth() {  
        return formatDate(new Date(), "MM");  
    }  
  
    /** 
     * 得到当天字符串 格式（dd） 
     */  
    public static String getDay() {  
        return formatDate(new Date(), "dd");  
    }  
  
    /** 
     * 得到当前星期字符串 格式（E）星期几 
     */  
    public static String getWeek() {  
        return formatDate(new Date(), "E");  
    }  
  
    /** 
     * 日期型字符串转化为日期 格式 
     * { "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", 
     * "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", 
     * "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm" } 
     */  
    public static Date parseDate(Object str) {  
        if (str == null) {  
            return null;  
        }  
        try {  
            return parseDate(str.toString(), parsePatterns);  
        } catch (ParseException e) {  
            return null;  
        }  
    }  
  
    /** 
     * 获取过去的天数 
     * 
     * @param date 
     * @return 
     */  
    public static long pastDays(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (24 * 60 * 60 * 1000);  
    }  
  
    /** 
     * 获取过去的小时 
     * 
     * @param date 
     * @return 
     */  
    public static long pastHour(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (60 * 60 * 1000);  
    }  
  
    /** 
     * 获取过去的分钟 
     * 
     * @param date 
     * @return 
     */  
    public static long pastMinutes(Date date) {  
        long t = new Date().getTime() - date.getTime();  
        return t / (60 * 1000);  
    }  
  
    /** 
     * 转换为时间（天,时:分:秒.毫秒） 
     * 
     * @param timeMillis 
     * @return 
     */  
    public static String formatDateTime(long timeMillis) {  
        long day = timeMillis / (24 * 60 * 60 * 1000);  
        long hour = (timeMillis / (60 * 60 * 1000) - day * 24);  
        long min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);  
        long s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);  
        long sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);  
        return (day > 0 ? day + "," : "") + hour + ":" + min + ":" + s + "." + sss;  
    }  
  
    /** 
     * 获取两个日期之间的天数 
     * 
     * @param before 
     * @param after 
     * @return 
     */  
    public static double getDistanceOfTwoDate(Date before, Date after) {  
        long beforeTime = before.getTime();  
        long afterTime = after.getTime();  
        return (afterTime - beforeTime) / (1000 * 60 * 60 * 24);  
    }  
  
    public static String getFirstDayOfMonth() {  
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");  
        //获取当前月第一天：  
        Calendar c = Calendar.getInstance();  
        c.add(Calendar.MONTH, 0);  
        c.set(Calendar.DAY_OF_MONTH, 1);//设置为1号,当前日期既为本月第一天  
        String first = format.format(c.getTime());  
        return first;  
    }  
  
    /** 
     * @param args 
     * @throws ParseException 
     */  
    public static void main(String[] args) throws ParseException {  
//      System.out.println(formatDate(parseDate("2010/3/6")));  
      System.out.println(getDate("yyyy-MM-dd HH:mm"));  
//      long time = new Date().getTime()-parseDate("2012-11-19").getTime();  
//      System.out.println(time/(24*60*60*1000));  
    }  
}
```

```java

```

