#### dubbo和mq的使用场景（）

```
dubbo

1，rpc的分布式集群支持：负载均衡是对外提供一个公共地址，请求过来时通过轮询、随机的形式来分摊压力，挂一台补一台
2，结合zookeeper解藕：(提供者注册和消费者订阅)客户端和服务端启动的时候都会把自己的机器IP注册到zookeeper上。客户端会把zk上的服务端ip拉到磁盘上，并记录哪些ip提供哪些服务（服务端启动的时候暴露给zk）。
   然后调用的时候客户端会根据ip调用服务端的服务，这时候即使zk挂掉也没关系。
3：长连接通讯：nio通信抽象封装（暂时没接触）

可用场景：
1，商城做活动流量暴涨：防止系统崩掉 可以通过dubbo来控制访问量
2，分布式服务器rpc过程调用压力分担

 

mq的问题的起源：

对分布式系统研究的 CAP定律    分布式事务有强一致，弱一致，和最终一致性  只能同时满足2点，三者不能兼得

比如有订单，库存两个数据，一个下单过程简化为，加一个订单，减一个库存。 而订单和库存是独立的服务，那怎么保证数据一致性

保证两个远程调用“同时成功”，数据一致 当然失败和超时都有可能 ，一般的解决方案，大多数的做法是借助mq来做最终一致

 

mq一个点对点一个是分布式订阅：

mq的2个好处是：
1，消息不丢失：服务之间端掉消息会保存到mq中间件中，当消费者服务器恢复后就会重新发过去，消息不会丢失
2，异步处理：比如一个商城用户购买产品后后台会去更新数据库然后响应给客户端，如果在高并发的情况下，
这样更新数据库响应客户端会变慢，可以使用mq消息队列的消费者进程中获取数据来进行异步写数据，由于消息对垒的服务处理速度远快于数据库，
因此响应延迟能得到有效改善
```

#### @Resource与@Autowired注解 的区别

```
  @Resource与@Autowired注解在一般使用情况下，它们的使用效果是一致的，但是相对而言，@Resource注解的功能更加强悍，@Resource可以根据名称进行指派。

    · 如果在Spring的配置文件中，注入一个新的Bean，如下所示：
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:p="http://www.springframework.org/schema/p"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans 
            http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
            http://www.springframework.org/schema/context 
            http://www.springframework.org/schema/context/spring-context-4.3.xsd">  
        <context:component-scan base-package="cn.mldn.mldnspring"/>	<!-- 定义扫描包 -->
        <bean id="newDeptDAOImpl" class="cn.springdemo.dao.impl.DeptDAOImpl"/> 
    </beans>

    · 同样在相应的dao子类上，采用注解的方式进行注入，如下所示：
        public interface IDeptDAO {
            public boolean doCreate(Dept vo) ;
        }

        @Repository 
        public class DeptDAOImpl implements IDeptDAO {
            @Override
            public boolean doCreate(Dept vo) {
                System.err.println("数据层-----" + vo);
                return true;
            }
        }

        @Repository等价于在配置文件上注入如下bean：
        <bean id="deptDAOImpl" class="cn.springdemo.dao.impl.DeptDAOImpl"/> 


    业务层以及测试类如下：
    业务层：
        public interface IDeptService {
            public boolean add(Dept vo) ; 
        }

        @Service
        public class DeptServiceImpl implements IDeptService {
            @Autowired
            private IDeptDAO deptDAO ;	// 自动根据类型注入  
            
            @Override
            public boolean add(Dept vo) {
                return this.deptDAO.doCreate(vo); 
            }
        }
    

    测试类：
    @ContextConfiguration(locations= {"classpath:spring/spring-base.xml"})
    @RunWith(SpringJUnit4ClassRunner.class)
    public class TestDeptService {
        @Autowired
        public void setDeptService(IDeptService deptService) {
            this.deptService = deptService;
        }
        @Test
        public void testAdd() {
            Dept vo = new Dept() ;
            vo.setDeptno(99L);
            vo.setDname("开发部");
            System.out.println(this.deptService.add(vo));
        }
    }

    vo类：
        public class Dept implements Serializable {
            private Long deptno ;
            private String dname ;
            public Dept() {
                System.out.println("*************** 实例化Dept类对象 ***************");
            }
            public Long getDeptno() {
                return deptno;
            }
            public void setDeptno(Long deptno) {
                this.deptno = deptno;
            }
            public String getDname() {
                return dname;
            }
            public void setDname(String dname) {
                this.dname = dname;
            }
            @Override
            public String toString() {
                return "【" + super.toString() + "】deptno = " + this.deptno + "、dname = " + this.dname;
            }
        }

    
    此时允许Junit测试程序，发现如下错误:
    Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'cn.springdemo.dao.IDeptDAO' available: 
    expected single matching bean but found 2: deptDAOImpl,newDeptDAOImpl


    而如果此时将注入类型的名称变为相应的，如下所示：
    @Service
    public class DeptServiceImpl implements IDeptService {
        @Autowired
        private IDeptDAO deptDAOImpl ;	// 自动根据类型注入  
        
        @Override
        public boolean add(Dept vo) {
            return this.deptDAOImpl.doCreate(vo); 
        }
    }

    此时Junit程序运行正常。因为名称匹配（默认使用注解，给出的bean的id将类的首字母变为小写，其他照常）可以自动根据byName匹配,而如果名称不匹配的时候会根据byType注入，
而当byType的时候就会发现两个同样类型的bean对象存在，自然就会出现如上的错误提示，而@Resource也有byName与byType的支持。
    *************** 实例化Dept类对象 ***************
    【数据层】【cn.springdemo.vo.Dept@6e0dec4a】deptno = 99、dname = 开发部
    true


    但是@Resource的支持更加的强大，@Resource可以在注入的时候指定具体的bean的名称。如下所示：
    @Service
    public class DeptServiceImpl implements IDeptService {
        @Resource(name="deptDAOImpl")
        private IDeptDAO deptDAO ;	// 自动根据类型注入        
        @Override
        public boolean add(Dept vo) {
            return this.deptDAO.doCreate(vo); 
        }
    }
    此时代码正常运行。

    虽然@Autowired无法直接指定具体bean的名称，但是在Spring中提供了另外的一个注解@Qualified来辅助它实现bean名称的配置。
    @Service
    public class DeptServiceImpl implements IDeptService {
        @Autowired
        @Qualifier("deptDAOImpl")
        private IDeptDAO deptDAO ;	// 自动根据类型注入  
        @Override
        public boolean add(Dept vo) {
            return this.deptDAO.doCreate(vo); 
        }
    }



    所示可以从以上得出如下的结论：
        ① @Resource注解是由JavaEE标准定义的资源注入,@Autowired是Spring自己定义的。
        ② 在使用的时候@Resource和@Autowired都具有ByName和ByType的支持。
        ③ @Resource可以利用name的属性进行指定bean的注入。如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。
          如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。
        ④ @Autowired本身没有指定bean的注入支持，但是Spring提供了@Qualifier注解来辅助它的功能，但是相对于@Resource来说比较麻烦一点。
        ⑤ @Autowired默认按照ByType匹配方式在容器中查找匹配的Bean，而@Resources默认按照ByName匹配方式在容器中查找匹配的Bean。
        ⑥ 除此之外，在JavaEE标准之中还提供有@Inject注解，功能与上面两者类似。@Inject和@Autowired一样也是默认按照ByType匹配方式在容器中查找匹配的Bean，
          但是它没有require属性，不能对找不到对应的bean的异常做关闭的操作。
```

Token 的身份验证

#### Cookie与Session的区别

```
   · Cookie保存在客户端，Session保存在服务器端。
    · 由于HTTP协议不保存有用户的状态，所以服务器会自动在浏览器上保存有一个Cookie的数据，该数据存放的是SessionID的信息，并且
    在每一发出请求之后服务器端可以根据此SessionID来判断用户是否为第一次访问，以及可以根据SessionID获取指定数据。
    · 如果在Cookie被禁用的情况下， 那么默认状态下，Session将无法进行保存处理，这个时候最初的做法可以采用地址重写的方式，在每
    一个请求路径使用地址重写的方式，将JESSIONID发送到服务器端，随着浏览器的进步，对于Cooie的禁用操作已不再做设计考虑了。
    注：session属性在未关闭浏览器之前都可以进行保存，而且每一个session只保存一个独立的用户信息，不同的session之间不能够进行
    访问。
    注：session并不会因为浏览器关闭而销毁，而是会默认保存30分钟，session销毁的方式：① 手工注销；② 时间到了，自动销毁。


    Session操作原理：
        · session的整个操作过程之中一定用到了Cookie的机制。
        · 当用户第一次进行访问的时候，会在服务器端为其分配一个SESSIONID，并且将这个SessionID自动的保存在客户端浏览器上，也就是
        说可以利用是否在请求头信息中出现过JESSIONID来判断是否是新用户。
        · 每当用户发出请求之后，会自动的将JESSIONID发送到服务器端上，服务器端会通过发送来的Cookie自动取得JESSIONID，并将内容与
        服务器端上的SESSIONID进行匹配，以确定不同用户。
```

#### 务器端跳转与客户端跳转 

```
① 服务器端跳转：请求地址不发生改变（跳转之后的地址栏不改变），可以传递request属性范围，无条件跳转，

               跳转之后的程序不再执行；

  实现技术：<jsp:forward page="跳转路径">



② 客户端跳转：请求地址发生改变（相当于发出二次请求），无法传递request属性范围，所有代码执行完再跳转。

  实现技术：a. HTML超链接：<a href="地址"> </a>

           b. JS:window.location ="跳转路径";

           c. response对象：response.sendRedirect();

           d. 头信息设置跳转：response.setHeader("refresh","2;URL=路径 ");
```